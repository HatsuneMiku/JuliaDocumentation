<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=Shift_JIS">
  <title>プロファイリング</title>
</head>
<body>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr style="font-weight: bold;">
      <td style="vertical-align: top;" rowspan="1" colspan="4">プロファイリング<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">書式<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">機能<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">例題<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">結果<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@profile() </td>
      <td style="vertical-align: top;">@profile &lt;expression&gt; runs
your expression
while taking periodic backtraces. These are appended to an internal
buffer of backtraces.<br>
The methods in Base.Profile are not exported and need to be called e.g.
as Profile.print().<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">clear() </td>
      <td style="vertical-align: top;">Clear any existing backtraces
from the internal
buffer.<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">print([io::IO = STDOUT,
][data::Vector]; format = :tree, C = false,
combine = true, cols = tty_cols(), maxdepth = typemax(Int), sortedby =
:filefuncline) </td>
      <td style="vertical-align: top;">Prints profiling results to io
(by default, STDOUT).
If you do not supply a data vector, the internal buffer of accumulated
backtraces will be used. format can be :tree or :flat. If C==true,
backtraces from C and Fortran code are shown. combine==true merges
instruction pointers that correspond to the same line of code. cols
controls the width of the display. maxdepth can be used to limit the
depth of printing in :tree format, while sortedby can be used to
control the order in :flat format (:filefuncline sorts by the source
line, whereas :count sorts in order of number of collected samples).<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">print([io::IO = STDOUT,
]data::Vector, lidict::Dict; kwargs) </td>
      <td style="vertical-align: top;">Prints profiling results to io.
This variant is used
to examine results exported by a previous call to retrieve(). Supply
the vector data of backtraces and a dictionary lidict of line
information.<br>
See Profile.print([io], data) for an explanation of
the valid keyword arguments.<br>
      <br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">init(; n::Integer,
delay::Float64) </td>
      <td style="vertical-align: top;">Configure the delay between
backtraces (measured in
seconds), and the number n of instruction pointers that may be stored.
Each instruction pointer corresponds to a single line of code;
backtraces generally consist of a long list of instruction pointers.
Default settings can be obtained by calling this function with no
arguments, and each can be set independently using keywords or in the
order (n, delay).<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">fetch() → data </td>
      <td style="vertical-align: top;">Returns a reference to the
internal buffer of
backtraces. Note that subsequent operations, like clear(), can affect
data unless you first make a copy. Note that the values in data have
meaning only on this machine in the current session, because it depends
on the exact memory addresses used in JIT-compiling. This function is
primarily for internal use; retrieve() may be a better choice for most
users.<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">retrieve() → data, lidict </td>
      <td style="vertical-align: top;">“Exports” profiling results in a
portable format,
returning the set of all backtraces (data) and a dictionary that maps
the (session-specific) instruction pointers in data to LineInfo values
that store the file name, function name, and line number. This function
allows you to save profiling results for future analysis.<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">callers(funcname[, data,
lidict][, filename=&lt;filename&gt;][,
linerange=&lt;start:stop&gt;]) → Vector{Tuple{count, linfo}}¶ </td>
      <td style="vertical-align: top;">Given a previous profiling run,
determine who called
a particular function. Supplying the filename (and optionally, range of
line numbers over which the function is defined) allows you to
disambiguate an overloaded method. The returned value is a vector
containing a count of the number of calls and line information about
the caller. One can optionally supply backtrace data obtained from
retrieve(); otherwise, the current internal profile buffer is used.<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">clear_malloc_data() </td>
      <td style="vertical-align: top;">Clears any stored memory
allocation data when
running julia with --track-allocation. Execute the command(s) you want
to test (to force JIT-compilation), then call clear_malloc_data(). Then
execute your command(s) again, quit Julia, and examine the resulting
*.mem files.<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
</body>
</html>
