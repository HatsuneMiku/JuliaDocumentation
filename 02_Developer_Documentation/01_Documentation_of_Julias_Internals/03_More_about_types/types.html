<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]--><!--[if gt IE 8]><!--><!--<![endif]-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>More about types — Julia Language 0.4.3 documentation</title>
  <link
 href="https://fonts.googleapis.com/css?family=Lato:400,700%7CRoboto+Slab:400,700%7CInconsolata:400,700"
 rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="top" title="Julia Language 0.4.3 documentation"
 href="../index.html">
  <link rel="up" title="Documentation of Julia’s Internals"
 href="julia.html">
  <link rel="next" title="Memory layout of Julia Objects"
 href="object.html">
  <link rel="prev" title="Julia ASTs" href="ast.html">
  <script
 src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav"> <nav data-toggle="wy-nav-shift"
 class="wy-nav-side"> </nav>
<div class="rst-content">
<div role="main" class="document">
<div class="section" id="more-about-types">
<h1>More about types<a class="headerlink" href="#more-about-types"
 title="Permalink to this headline">¶</a></h1>
<p>If you’ve used Julia for a while, you understand the fundamental
role
that types play. Here we try to get under the hood, focusing
particularly on <a class="reference internal"
 href="../manual/types.html#man-parametric-types"><span>parametric types</span></a>.</p>
<div class="section" id="types-and-sets-and-any-and-union-bottom">
<h2>Types and sets (and <code class="docutils literal"><span
 class="pre">Any</span></code> and <code class="docutils literal"><span
 class="pre">Union{}</span></code>/<code class="docutils literal"><span
 class="pre">Bottom</span></code>)<a class="headerlink"
 href="#types-and-sets-and-any-and-union-bottom"
 title="Permalink to this headline">¶</a></h2>
<p>It’s perhaps easiest to conceive of Julia’s type system in terms of
sets. A concrete type corresponds to a single entity in the space of
all possible types; an abstract type refers to a collection (set) of
concrete types. <code class="docutils literal"><span class="pre">Any</span></code>
is a type that describes the entire universe
of possible types; <code class="docutils literal"><span class="pre">Integer</span></code>
is a subset of <code class="docutils literal"><span class="pre">Any</span></code>
that includes
<code class="docutils literal"><span class="pre">Int</span></code>, <code
 class="docutils literal"><span class="pre">Int8</span></code>, and
other concrete types. Internally, Julia also
makes heavy use of another type known as <code class="docutils literal"><span
 class="pre">Bottom</span></code>, or equivalently,
<code class="docutils literal"><span class="pre">Union{}</span></code>.
This corresponds to the empty set.</p>
<p>Julia’s types support the standard operations of set theory: you can
ask whether <code class="docutils literal"><span class="pre">T1</span></code>
is a “subset” (subtype) of <code class="docutils literal"><span
 class="pre">T2</span></code> with <code class="docutils literal"><span
 class="pre">T1</span> <span class="pre">&lt;:</span>
<span class="pre">T2</span></code>. Likewise, you intersect two types
using <code class="docutils literal"><span class="pre">typeintersect</span></code>,
take
their union with <code class="docutils literal"><span class="pre">Union</span></code>,
and compute a type that contains their
union with <code class="docutils literal"><span class="pre">typejoin</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">typeintersect</span><span class="p">(</span><span class="kt">Int</span><span
 class="p">,</span> <span class="kt">Float64</span><span class="p">)</span>
<span class="n">Union</span><span class="p">{}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Union</span><span
 class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span
 class="kt">Float64</span><span class="p">}</span>
<span class="n">Union</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">,</span><span class="kt">Int64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typejoin</span><span
 class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span
 class="kt">Float64</span><span class="p">)</span>
<span class="n">Real</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Signed</span><span class="p">,</span> <span
 class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span
 class="p">,</span> <span class="kt">Int8</span><span class="p">})</span>
<span class="kt">Int8</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Union</span><span
 class="p">{</span><span class="n">Signed</span><span class="p">,</span> <span
 class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span
 class="p">,</span> <span class="kt">Int8</span><span class="p">}}</span>
<span class="n">Union</span><span class="p">{</span><span class="n">Signed</span><span
 class="p">,</span><span class="n">UInt8</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typejoin</span><span
 class="p">(</span><span class="n">Signed</span><span class="p">,</span> <span
 class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span
 class="p">,</span> <span class="kt">Int8</span><span class="p">})</span>
<span class="n">Integer</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span
 class="p">})</span>
<span class="n">Tuple</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Union</span><span
 class="p">{</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span
 class="p">}}</span>
<span class="n">Union</span><span class="p">{</span><span class="n">Tuple</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span
 class="n">Real</span><span class="p">},</span><span class="n">Tuple</span><span
 class="p">{</span><span class="n">Integer</span><span class="p">,</span><span
 class="kt">Float64</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typejoin</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span
 class="p">})</span>
<span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span
 class="p">,</span><span class="n">Real</span><span class="p">}</span>
</pre>
</div>
</div>
<p>While these operations may seem abstract, they lie at the heart of
Julia. For example, method dispatch is implemented by stepping
through the items in a method list until reaching one for which
<code class="docutils literal"><span class="pre">typeintersect(args,</span>
<span class="pre">sig)</span></code> is not <code
 class="docutils literal"><span class="pre">Union{}</span></code>.
(Here, <code class="docutils literal"><span class="pre">args</span></code>
is a
tuple-type describing the types of the arguments, and <code
 class="docutils literal"><span class="pre">sig</span></code> is a
tuple-type specifying the types in the function’s signature.) For
this algorithm to work, it’s important that methods be sorted by their
specificity, and that the search begins with the most specific
methods. Consequently, julia also implements a partial order on
types; this is achieved by functionality that is similar to <code
 class="docutils literal"><span class="pre">&lt;:</span></code>,
but with differences that will be discussed below.</p>
</div>
<div class="section" id="typevars">
<h2>TypeVars<a class="headerlink" href="#typevars"
 title="Permalink to this headline">¶</a></h2>
<p>Many types take parameters; an easy example is <a
 class="reference internal" href="../stdlib/arrays.html#Base.Array"
 title="Base.Array"><code class="xref jl jl-obj docutils literal"><span
 class="pre">Array</span></code></a>, which takes
two parameters often written as <code class="docutils literal"><span
 class="pre">Array{T,N}</span></code>. Let’s compare the
following methods:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">f1</span><span class="p">(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">)</span> <span
 class="o">=</span> <span class="mi">1</span>
<span class="n">f2</span><span class="p">(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">})</span> <span class="o">=</span> <span
 class="mi">2</span>
<span class="n">f3</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(</span><span class="n">A</span><span class="p">::</span><span
 class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">})</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">f4</span><span class="p">(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Any</span><span class="p">})</span> <span class="o">=</span> <span
 class="mi">4</span>
<span class="n">f5</span><span class="p">{</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="kt">Any</span><span class="p">}(</span><span
 class="n">A</span><span class="p">::</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">})</span> <span
 class="o">=</span> <span class="mi">5</span>
</pre>
</div>
</div>
<p>All but <code class="docutils literal"><span class="pre">f4</span></code>
can be called with <code class="docutils literal"><span class="pre">a</span>
<span class="pre">=</span> <span class="pre">[1,2]</span></code>; all
but <code class="docutils literal"><span class="pre">f2</span></code>
can be
called with <code class="docutils literal"><span class="pre">b</span> <span
 class="pre">=</span> <span class="pre">Any[1,2]</span></code>.</p>
<p>Let’s look at these types a little more closely:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Array</span>
<span class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">xdump</span><span
 class="p">(</span><span class="n">Array</span><span class="p">)</span>
<span class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">}::</span><span
 class="n">DataType</span>  <span class="o">&lt;:</span> <span class="n">DenseArray</span><span
 class="p">{</span><span class="n">T</span><span class="p">,</span><span
 class="n">N</span><span class="p">}</span>
</pre>
</div>
</div>
<p>This indicates that <a class="reference internal"
 href="../stdlib/arrays.html#Base.Array" title="Base.Array"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>
is a shorthand for <code class="docutils literal"><span class="pre">Array{T,N}</span></code>.
If
you type this at the REPL prompt—on its own, not while defining
a function or type—you get an error <code class="docutils literal"><span
 class="pre">T</span> <span class="pre">not</span> <span class="pre">defined</span></code>.
So what,
exactly, are <code class="docutils literal"><span class="pre">T</span></code>
and <code class="docutils literal"><span class="pre">N</span></code>?
You can learn more by extracting these
parameters:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">T</span><span class="p">,</span><span class="n">N</span> <span
 class="o">=</span> <span class="n">Array</span><span class="o">.</span><span
 class="n">parameters</span>
<span class="n">svec</span><span class="p">(</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">xdump</span><span
 class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">TypeVar</span>
  <span class="n">name</span><span
 class="p">:</span> <span class="n">Symbol</span> <span class="n">T</span>
  <span
 class="n">lb</span><span class="p">:</span> <span class="n">Union</span><span
 class="p">{}</span>
  <span class="n">ub</span><span class="p">:</span> <span
 class="kt">Any</span><span class="p">::</span><span class="n">DataType</span>  <span
 class="o">&lt;:</span> <span class="kt">Any</span>
  <span class="n">bound</span><span
 class="p">:</span> <span class="kt">Bool</span> <span class="n">false</span>
</pre>
</div>
</div>
<p>A <code class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
is one of Julia’s built-in types—it’s defined in
<code class="docutils literal"><span class="pre">jltypes.c</span></code>,
although you can find a commented-out version in
<code class="docutils literal"><span class="pre">boot.jl</span></code>.
The <code class="docutils literal"><span class="pre">name</span></code>
field is straightforward: it’s what’s
printed when showing the object. <code class="docutils literal"><span
 class="pre">lb</span></code> and <code class="docutils literal"><span
 class="pre">ub</span></code> stand for “lower
bound” and “upper bound,” respectively: these are the sets that
constrain what types the TypeVar may represent. In this case, <code
 class="docutils literal"><span class="pre">T</span></code>‘s
lower bound is <code class="docutils literal"><span class="pre">Union{}</span></code>
(i.e., <code class="docutils literal"><span class="pre">Bottom</span></code>
or the empty set); in
other words, this <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code> is not constrained from below. The
upper bound is <code class="docutils literal"><span class="pre">Any</span></code>,
so neither is it constrained from above.</p>
<p>In a method definition like:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">g</span><span class="p">{</span><span class="n">S</span><span
 class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span
 class="n">x</span><span class="p">::</span><span class="n">S</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre>
</div>
</div>
<p>one can extract the underlying <code
 class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">g</span><span class="p">{</span><span class="n">S</span><span
 class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span
 class="n">x</span><span class="p">::</span><span class="n">S</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">start</span><span
 class="p">(</span><span class="n">methods</span><span class="p">(</span><span
 class="n">g</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span
 class="o">.</span><span class="n">sig</span><span class="o">.</span><span
 class="n">parameters</span>
<span class="n">tv</span> <span class="o">=</span> <span class="n">p</span><span
 class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">xdump</span><span class="p">(</span><span class="n">tv</span><span
 class="p">)</span>
</pre>
</div>
</div>
<div class="highlight-none">
<div class="highlight">
<pre>TypeVar<br>  name: Symbol S<br>  lb: Union{}<br>  ub: Integer::DataType  &lt;: Real<br>  bound: Bool true<br></pre>
</div>
</div>
<p>Here <code class="docutils literal"><span class="pre">ub</span></code>
is <code class="docutils literal"><span class="pre">Integer</span></code>,
as specified in the function definition.</p>
<p>The last field of a <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code> is <code class="docutils literal"><span
 class="pre">bound</span></code>. This boolean value
specifies whether the <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code> is defined as one of the function
parameters. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">h1</span><span class="p">(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">,</span> <span
 class="n">b</span><span class="p">::</span><span class="n">Real</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">h1</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">h2</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">,</span> <span
 class="n">b</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">h2</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">h3</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">{</span><span
 class="n">T</span><span class="p">},</span> <span class="n">b</span><span
 class="p">::</span><span class="n">T</span><span class="p">)</span> <span
 class="o">=</span> <span class="mi">1</span>
<span class="n">h3</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">p1</span> <span
 class="o">=</span> <span class="n">start</span><span class="p">(</span><span
 class="n">methods</span><span class="p">(</span><span class="n">h1</span><span
 class="p">))</span><span class="o">.</span><span class="n">sig</span><span
 class="o">.</span><span class="n">parameters</span>
<span class="n">svec</span><span class="p">(</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">,</span><span
 class="n">N</span><span class="p">},</span><span class="n">Real</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">p2</span> <span
 class="o">=</span> <span class="n">start</span><span class="p">(</span><span
 class="n">methods</span><span class="p">(</span><span class="n">h2</span><span
 class="p">))</span><span class="o">.</span><span class="n">sig</span><span
 class="o">.</span><span class="n">parameters</span>
<span class="n">svec</span><span class="p">(</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">,</span><span
 class="n">N</span><span class="p">},</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="n">Real</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">p3</span> <span
 class="o">=</span> <span class="n">start</span><span class="p">(</span><span
 class="n">methods</span><span class="p">(</span><span class="n">h3</span><span
 class="p">))</span><span class="o">.</span><span class="n">sig</span><span
 class="o">.</span><span class="n">parameters</span>
<span class="n">svec</span><span class="p">(</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">,</span><span class="n">N</span><span
 class="p">},</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">xdump</span><span
 class="p">(</span><span class="n">p1</span><span class="p">[</span><span
 class="mi">1</span><span class="p">]</span><span class="o">.</span><span
 class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span
 class="p">])</span>
<span class="n">TypeVar</span>
  <span class="n">name</span><span
 class="p">:</span> <span class="n">Symbol</span> <span class="n">T</span>
  <span
 class="n">lb</span><span class="p">:</span> <span class="n">Union</span><span
 class="p">{}</span>
  <span class="n">ub</span><span class="p">:</span> <span
 class="kt">Any</span><span class="p">::</span><span class="n">DataType</span>  <span
 class="o">&lt;:</span> <span class="kt">Any</span>
  <span class="n">bound</span><span
 class="p">:</span> <span class="kt">Bool</span> <span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">xdump</span><span
 class="p">(</span><span class="n">p3</span><span class="p">[</span><span
 class="mi">1</span><span class="p">]</span><span class="o">.</span><span
 class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span
 class="p">])</span>
<span class="n">TypeVar</span>
  <span class="n">name</span><span
 class="p">:</span> <span class="n">Symbol</span> <span class="n">T</span>
  <span
 class="n">lb</span><span class="p">:</span> <span class="n">Union</span><span
 class="p">{}</span>
  <span class="n">ub</span><span class="p">:</span> <span
 class="n">Real</span><span class="p">::</span><span class="n">DataType</span>  <span
 class="o">&lt;:</span> <span class="n">Number</span>
  <span class="n">bound</span><span
 class="p">:</span> <span class="kt">Bool</span> <span class="n">true</span>
</pre>
</div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">p2</span></code>
shows two objects called <code class="docutils literal"><span
 class="pre">T</span></code>, but only one of them
has the upper bound <code class="docutils literal"><span class="pre">Real</span></code>;
in contrast, <code class="docutils literal"><span class="pre">p3</span></code>
shows both of them
bounded. This is because in <code class="docutils literal"><span
 class="pre">h3</span></code>, the same type <code
 class="docutils literal"><span class="pre">T</span></code> is used in
both places, whereas for <code class="docutils literal"><span
 class="pre">h2</span></code> the <code class="docutils literal"><span
 class="pre">T</span></code> inside the array is simply
the default symbol used for the first parameter of <a
 class="reference internal" href="../stdlib/arrays.html#Base.Array"
 title="Base.Array"><code class="xref jl jl-obj docutils literal"><span
 class="pre">Array</span></code></a>.</p>
<p>One can construct <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code>s manually:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">TypeVar</span><span class="p">(:</span><span class="n">V</span><span
 class="p">,</span> <span class="n">Signed</span><span class="p">,</span> <span
 class="n">Real</span><span class="p">,</span> <span class="n">false</span><span
 class="p">)</span>
<span class="n">Signed</span><span class="o">&lt;:</span><span class="n">V</span><span
 class="o">&lt;:</span><span class="n">Real</span>
</pre>
</div>
</div>
<p>There are convenience versions that allow you to omit any of these
arguments except the <code class="docutils literal"><span class="pre">name</span></code>
symbol.</p>
<p>Armed with this information, we can do some sneaky things that
reveal
a lot about how Julia does dispatch:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">TV</span> <span class="o">=</span> <span class="n">TypeVar</span><span
 class="p">(:</span><span class="n">T</span><span class="p">,</span> <span
 class="n">false</span><span class="p">)</span>   <span class="c"># bound = false</span>
<span class="n">T</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">candid</span><span
 class="p">{</span><span class="n">T</span><span class="p">}(</span><span
 class="n">A</span><span class="p">::</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">},</span> <span
 class="n">x</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">candid</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">@</span><span
 class="n">eval</span> <span class="n">sneaky</span><span class="p">{</span><span
 class="n">T</span><span class="p">}(</span><span class="n">A</span><span
 class="p">::</span><span class="n">Array</span><span class="p">{</span><span
 class="n">T</span><span class="p">},</span> <span class="n">x</span><span
 class="p">::</span><span class="o">$</span><span class="n">TV</span><span
 class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">sneaky</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">methods</span><span
 class="p">(</span><span class="n">candid</span><span class="p">)</span>
<span class="c"># 1 method for generic function "candid":</span>
<span class="n">candid</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(</span><span class="n">A</span><span class="p">::</span><span
 class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">},</span> <span
 class="n">x</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span> <span class="n">at</span> <span class="n">none</span><span
 class="p">:</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">methods</span><span
 class="p">(</span><span class="n">sneaky</span><span class="p">)</span>
<span class="c"># 1 method for generic function "sneaky":</span>
<span class="n">sneaky</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(</span><span class="n">A</span><span class="p">::</span><span
 class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">},</span> <span
 class="n">x</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span> <span class="n">at</span> <span class="n">none</span><span
 class="p">:</span><span class="mi">1</span>
</pre>
</div>
</div>
<p>These therefore print identically, but they have very different
behavior:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">candid</span><span class="p">([</span><span class="mi">1</span><span
 class="p">],</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span
 class="p">:</span> <span class="sb">`candid`</span> <span class="n">has</span> <span
 class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span
 class="n">candid</span><span class="p">(::</span><span class="n">Array</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span
 class="mi">1</span><span class="p">},</span> <span class="p">::</span><span
 class="kt">Float64</span><span class="p">)</span>
<span class="n">Closest</span> <span class="n">candidates</span> <span
 class="n">are</span><span class="p">:</span>
  <span class="n">candid</span><span
 class="p">{</span><span class="n">T</span><span class="p">}(::</span><span
 class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">},</span> <span
 class="o">!</span><span class="n">Matched</span><span class="p">::</span><span
 class="n">T</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sneaky</span><span
 class="p">([</span><span class="mi">1</span><span class="p">],</span><span
 class="mf">3.2</span><span class="p">)</span>
<span class="mi">1</span>
</pre>
</div>
</div>
<p>To see what’s happening, it’s helpful to use Julia’s internal <code
 class="xref c c-func docutils literal"><span class="pre">jl_()</span></code>
function (defined in <code class="docutils literal"><span class="pre">builtins.c</span></code>)
for display, because it prints
bound <code class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
objects with a hash (<code class="docutils literal"><span class="pre">#T</span></code>
instead of <code class="docutils literal"><span class="pre">T</span></code>):</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">jl_</span><span class="p">(</span><span class="n">x</span><span
 class="p">)</span> <span class="o">=</span> <span class="k">ccall</span><span
 class="p">(:</span><span class="n">jl_</span><span class="p">,</span> <span
 class="n">Void</span><span class="p">,</span> <span class="p">(</span><span
 class="kt">Any</span><span class="p">,),</span> <span class="n">x</span><span
 class="p">)</span>
<span class="n">jl_</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>
</pre>
</div>
</div>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">jl_</span><span class="p">(</span><span class="n">start</span><span
 class="p">(</span><span class="n">methods</span><span class="p">(</span><span
 class="n">candid</span><span class="p">)))</span>
<span class="n">Method</span><span class="p">(</span><span class="n">sig</span><span
 class="o">=</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Array</span><span class="p">{</span><span class="c">#T&lt;:Any, N&lt;:Any}, #T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=#&lt;function&gt;, invokes=nothing, next=nothing)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">jl_</span><span
 class="p">(</span><span class="n">start</span><span class="p">(</span><span
 class="n">methods</span><span class="p">(</span><span class="n">sneaky</span><span
 class="p">)))</span>
<span class="n">Method</span><span class="p">(</span><span class="n">sig</span><span
 class="o">=</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Array</span><span class="p">{</span><span class="c">#T&lt;:Any, N&lt;:Any}, T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=#&lt;function&gt;, invokes=nothing, next=nothing)</span>
</pre>
</div>
</div>
<p>Even though both print as <code class="docutils literal"><span
 class="pre">T</span></code>, in <code class="docutils literal"><span
 class="pre">sneaky</span></code> the second <code
 class="docutils literal"><span class="pre">T</span></code> is
not bound, and hence it isn’t constrained to be the same type as the
element type of the <a class="reference internal"
 href="../stdlib/arrays.html#Base.Array" title="Base.Array"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>.</p>
<p>Some <code class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
interactions depend on the <code class="docutils literal"><span
 class="pre">bound</span></code> state, even when there are not two or
more uses of the same <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code>. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span
 class="p">(:</span><span class="n">S</span><span class="p">,</span> <span
 class="n">false</span><span class="p">);</span> <span class="n">T</span> <span
 class="o">=</span> <span class="n">TypeVar</span><span class="p">(:</span><span
 class="n">T</span><span class="p">,</span> <span class="n">true</span><span
 class="p">)</span>
<span class="n">T</span>

<span class="c"># These would be the same no matter whether we used S or T</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="n">S</span><span class="p">}}</span> <span class="o">&lt;:</span> <span
 class="n">Array</span><span class="p">{</span><span class="n">Array</span><span
 class="p">}</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="n">S</span><span class="p">}}</span> <span class="o">&lt;:</span> <span
 class="n">Array</span><span class="p">{</span><span class="n">Array</span><span
 class="p">{</span><span class="n">S</span><span class="p">}}</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">}</span> <span
 class="o">&lt;:</span> <span class="n">Array</span><span class="p">{</span><span
 class="n">Array</span><span class="p">{</span><span class="n">S</span><span
 class="p">}}</span>
<span class="n">true</span>

<span class="c"># For these cases, it matters</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">}}</span> <span class="o">&lt;:</span> <span
 class="n">Array</span><span class="p">{</span><span class="n">Array</span><span
 class="p">}</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">}}</span> <span class="o">&lt;:</span> <span
 class="n">Array</span><span class="p">{</span><span class="n">Array</span><span
 class="p">{</span><span class="n">S</span><span class="p">}}</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">}}</span> <span class="o">&lt;:</span> <span
 class="n">Array</span><span class="p">{</span><span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">}}</span>
<span class="n">true</span>
</pre>
</div>
</div>
<p>It’s this latter construction that allows function declarations like</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">foo</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">N</span><span class="p">}(</span><span
 class="n">A</span><span class="p">::</span><span class="n">Array</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="n">T</span><span class="p">,</span><span class="n">N</span><span
 class="p">}})</span> <span class="o">=</span> <span class="n">T</span><span
 class="p">,</span><span class="n">N</span>
</pre>
</div>
</div>
<p>to match despite the invariance of Julia’s type parameters.</p>
</div>
<div class="section" id="typenames">
<h2>TypeNames<a class="headerlink" href="#typenames"
 title="Permalink to this headline">¶</a></h2>
<p>The following two <a class="reference internal"
 href="../stdlib/arrays.html#Base.Array" title="Base.Array"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>
types are functionally equivalent, yet
print differently via <code class="xref c c-func docutils literal"><span
 class="pre">jl_()</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">TV</span><span class="p">,</span> <span class="n">NV</span> <span
 class="o">=</span> <span class="n">TypeVar</span><span class="p">(:</span><span
 class="n">T</span><span class="p">),</span> <span class="n">TypeVar</span><span
 class="p">(:</span><span class="n">N</span><span class="p">)</span>
<span class="p">(</span><span class="n">T</span><span class="p">,</span><span
 class="n">N</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">jl_</span><span
 class="p">(</span><span class="n">Array</span><span class="p">)</span>
<span class="n">Array</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">jl_</span><span
 class="p">(</span><span class="n">Array</span><span class="p">{</span><span
 class="n">TV</span><span class="p">,</span><span class="n">NV</span><span
 class="p">})</span>
<span class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="kt">Any</span><span class="p">,</span> <span
 class="n">N</span><span class="o">&lt;:</span><span class="kt">Any</span><span
 class="p">}</span>
</pre>
</div>
</div>
<p>These can be distinguished by examining the <code
 class="docutils literal"><span class="pre">name</span></code> field of
the type, which is an object of type <code
 class="xref jl jl-obj docutils literal"><span class="pre">TypeName</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">xdump</span><span class="p">(</span><span class="n">Array</span><span
 class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">TypeName</span>
  <span class="n">name</span><span
 class="p">:</span> <span class="n">Symbol</span> <span class="n">Array</span>
  <span
 class="k">module</span><span class="p">:</span> <span class="n">Module</span> <span
 class="n">Core</span>
  <span class="n">names</span><span class="p">:</span> <span
 class="n">SimpleVector</span>
    <span class="n">length</span><span
 class="p">:</span> <span class="kt">Int64</span> <span class="mi">0</span>
  <span
 class="n">primary</span><span class="p">:</span> <span class="n">Array</span><span
 class="p">{</span><span class="n">T</span><span class="p">,</span><span
 class="n">N</span><span class="p">}::</span><span class="n">DataType</span>  <span
 class="o">&lt;:</span> <span class="n">DenseArray</span><span class="p">{</span><span
 class="n">T</span><span class="p">,</span><span class="n">N</span><span
 class="p">}</span>
  <span class="n">cache</span><span class="p">:</span> <span
 class="n">SimpleVector</span>
    <span class="n">length</span><span
 class="p">:</span> <span class="kt">Int64</span> <span class="mi">135</span>
  <span
 class="n">linearcache</span><span class="p">:</span> <span class="n">SimpleVector</span>
    <span
 class="n">length</span><span class="p">:</span> <span class="kt">Int64</span> <span
 class="mi">18</span>
  <span class="nb">uid</span><span class="p">:</span> <span
 class="kt">Int64</span> <span class="mi">37</span>
</pre>
</div>
</div>
<p>In this case, the relevant field is <code class="docutils literal"><span
 class="pre">primary</span></code>, which holds a
reference to the “primary” instance of the type:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">pointer_from_objref</span><span class="p">(</span><span
 class="n">Array</span><span class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007fcc7de64850</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Array</span><span class="o">.</span><span
 class="n">name</span><span class="o">.</span><span class="n">primary</span><span
 class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007fcc7de64850</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Array</span><span class="p">{</span><span
 class="n">TV</span><span class="p">,</span><span class="n">NV</span><span
 class="p">})</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007fcc80c4d930</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Array</span><span class="p">{</span><span
 class="n">TV</span><span class="p">,</span><span class="n">NV</span><span
 class="p">}</span><span class="o">.</span><span class="n">name</span><span
 class="o">.</span><span class="n">primary</span><span class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007fcc7de64850</span>
</pre>
</div>
</div>
<p>The <code class="docutils literal"><span class="pre">primary</span></code>
field of <a class="reference internal"
 href="../stdlib/arrays.html#Base.Array" title="Base.Array"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>
points to itself, but for
<code class="docutils literal"><span class="pre">Array{TV,NV}</span></code>
it points back to the default definition of the type.</p>
<p>What about the other fields? <code class="docutils literal"><span
 class="pre">uid</span></code> assigns a unique integer to each
type. To examine the <code class="docutils literal"><span class="pre">cache</span></code>
field, it’s helpful to pick a type
that is less heavily used than Array. Let’s first create our own
type:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> MyType</span><span class="p">{</span><span
 class="n">T</span><span class="p">,</span><span class="n">N</span><span
 class="p">}</span> <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">MyType</span><span
 class="p">{</span><span class="kt">Int</span><span class="p">,</span><span
 class="mi">2</span><span class="p">}</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="mi">2</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">MyType</span><span
 class="p">{</span><span class="kt">Float32</span><span class="p">,</span> <span
 class="mi">5</span><span class="p">}</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Float32</span><span
 class="p">,</span><span class="mi">5</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">MyType</span><span
 class="o">.</span><span class="n">name</span><span class="o">.</span><span
 class="n">cache</span>
<span class="n">svec</span><span class="p">(</span><span class="n">MyType</span><span
 class="p">{</span><span class="kt">Float32</span><span class="p">,</span><span
 class="mi">5</span><span class="p">},</span><span class="n">MyType</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span
 class="mi">2</span><span class="p">},</span><span class="n">Evaluation</span> <span
 class="n">succeeded</span><span class="p">,</span> <span class="n">but</span> <span
 class="n">an</span> <span class="nb">error</span> <span class="n">occurred</span> <span
 class="k">while</span> <span class="n">showing</span> <span class="n">value</span> <span
 class="n">of</span> <span class="k">type</span><span class="nc"> SimpleVector</span><span
 class="p">:</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">UndefRefError</span><span
 class="p">:</span> <span class="n">access</span> <span class="n">to</span> <span
 class="n">undefined</span> <span class="n">reference</span>
 <span
 class="k">in</span> <span class="n">getindex</span> <span class="n">at</span> <span
 class="o">./</span><span class="n">essentials</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">211</span>
 <span
 class="k">in</span> <span class="n">show_delim_array</span> <span
 class="n">at</span> <span class="n">show</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">229</span>
 <span
 class="k">in</span> <span class="n">show</span> <span class="n">at</span> <span
 class="n">show</span><span class="o">.</span><span class="n">jl</span><span
 class="p">:</span><span class="mi">257</span>
 <span class="k">in</span> <span
 class="n">anonymous</span> <span class="n">at</span> <span class="n">show</span><span
 class="o">.</span><span class="n">jl</span><span class="p">:</span><span
 class="mi">1294</span>
 <span class="k">in</span> <span class="n">with_output_limit</span> <span
 class="n">at</span> <span class="o">./</span><span class="n">show</span><span
 class="o">.</span><span class="n">jl</span><span class="p">:</span><span
 class="mi">1271</span>
 <span class="k">in</span> <span class="n">showlimited</span> <span
 class="n">at</span> <span class="n">show</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">1293</span>
 <span
 class="k">in</span> <span class="n">display</span> <span class="n">at</span> <span
 class="n">multimedia</span><span class="o">.</span><span class="n">jl</span><span
 class="p">:</span><span class="mi">120</span>
 <span class="p">[</span><span
 class="n">inlined</span> <span class="n">code</span><span class="p">]</span> <span
 class="n">from</span> <span class="n">multimedia</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">151</span>
 <span
 class="k">in</span> <span class="n">display</span> <span class="n">at</span> <span
 class="n">multimedia</span><span class="o">.</span><span class="n">jl</span><span
 class="p">:</span><span class="mi">162</span>
</pre>
</div>
</div>
<p>(The error is triggered because the cache is pre-allocated to have
length 8, but only the first two entries are populated.)
Consequently, when you instantiate a parametric type, each concrete
type gets saved in a type-cache. However, instances with <code
 class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
parameters are not cached.</p>
</div>
<div class="section" id="tuple-types">
<h2>Tuple-types<a class="headerlink" href="#tuple-types"
 title="Permalink to this headline">¶</a></h2>
<p>Tuple-types constitute an interesting special case. For dispatch to
work on declarations like <code class="docutils literal"><span
 class="pre">x::Tuple</span></code>, the type has to be able to be
able to accommodate any tuple. Let’s check the parameters:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Tuple</span>
<span class="n">Tuple</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Tuple</span><span
 class="o">.</span><span class="n">parameters</span>
<span class="n">svec</span><span class="p">(</span><span class="n">Vararg</span><span
 class="p">{</span><span class="kt">Any</span><span class="p">})</span>
</pre>
</div>
</div>
<p>It’s worth noting that the parameter is a type, <code
 class="docutils literal"><span class="pre">Any</span></code>, rather
than a
<code class="docutils literal"><span class="pre">TypeVar</span> <span
 class="pre">T&lt;:Any</span></code>: compare</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">jl_</span><span class="p">(</span><span class="n">Tuple</span><span
 class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="n">svec</span><span class="p">(</span><span class="n">Vararg</span><span
 class="p">{</span><span class="kt">Any</span><span class="p">})</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">jl_</span><span
 class="p">(</span><span class="n">Array</span><span class="o">.</span><span
 class="n">parameters</span><span class="p">)</span>
<span class="n">svec</span><span class="p">(</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="kt">Any</span><span class="p">,</span> <span
 class="n">N</span><span class="o">&lt;:</span><span class="kt">Any</span><span
 class="p">)</span>
</pre>
</div>
</div>
<p>Unlike other types, tuple-types are covariant in their parameters,
so
this definition permits <code class="docutils literal"><span
 class="pre">Tuple</span></code> to match any type of tuple. This is
therefore equivalent to having an unbound <code
 class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
but distinct
from a bound <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code></p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span
 class="p">,</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">})</span>
<span class="n">Tuple</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Vararg</span><span class="p">{</span><span class="kt">Any</span><span
 class="p">}},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">})</span>
<span class="n">Tuple</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T</span> <span
 class="o">=</span> <span class="n">TypeVar</span><span class="p">(:</span><span
 class="n">T</span><span class="p">,</span><span class="n">false</span><span
 class="p">)</span>
<span class="n">T</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span
 class="p">}},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">})</span>
<span class="n">Tuple</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T</span> <span
 class="o">=</span> <span class="n">TypeVar</span><span class="p">(:</span><span
 class="n">T</span><span class="p">,</span><span class="n">true</span><span
 class="p">)</span>
<span class="n">T</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span
 class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span
 class="p">}},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span
 class="p">})</span>
<span class="n">Union</span><span class="p">{}</span>
</pre>
</div>
</div>
<p>Finally, it’s worth noting that <code class="docutils literal"><span
 class="pre">Tuple{}</span></code> is distinct</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Tuple</span><span class="p">{}</span>
<span class="n">Tuple</span><span class="p">{}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Tuple</span><span
 class="p">{}</span><span class="o">.</span><span class="n">parameters</span>
<span class="n">svec</span><span class="p">()</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{},</span> <span
 class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span
 class="p">})</span>
<span class="n">Union</span><span class="p">{}</span>
</pre>
</div>
</div>
<p>What is the “primary” tuple-type?</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">pointer_from_objref</span><span class="p">(</span><span
 class="n">Tuple</span><span class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007f5998a04370</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{})</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007f5998a570d0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Tuple</span><span class="o">.</span><span
 class="n">name</span><span class="o">.</span><span class="n">primary</span><span
 class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007f5998a04370</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">pointer_from_objref</span><span
 class="p">(</span><span class="n">Tuple</span><span class="p">{}</span><span
 class="o">.</span><span class="n">name</span><span class="o">.</span><span
 class="n">primary</span><span class="p">)</span>
<span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span
 class="p">}</span> <span class="p">@</span><span class="mh">0x00007f5998a04370</span>
</pre>
</div>
</div>
<p>so <code class="docutils literal"><span class="pre">Tuple</span> <span
 class="pre">==</span> <span class="pre">Tuple{Vararg{Any}}</span></code>
is indeed the primary type.</p>
</div>
<div class="section"
 id="introduction-to-the-internal-machinery-jltypes-c">
<h2>Introduction to the internal machinery: <code
 class="docutils literal"><span class="pre">jltypes.c</span></code><a
 class="headerlink"
 href="#introduction-to-the-internal-machinery-jltypes-c"
 title="Permalink to this headline">¶</a></h2>
<p>Many operations for dealing with types are found in the file
<code class="docutils literal"><span class="pre">jltypes.c</span></code>.
A good way to start is to watch type intersection in
action. Build Julia with <code class="docutils literal"><span
 class="pre">make</span> <span class="pre">debug</span></code> and
fire up Julia within a
debugger. <a class="reference internal"
 href="debuggingtips.html#devdocs-gdb"><span>gdb debugging tips</span></a>
has some tips which may be useful.</p>
<p>Because the type intersection and matching code is used heavily in
the
REPL itself—and hence breakpoints in this code get triggered
often—it will be easiest if you make the following definition:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">function</span><span class="nf"> myintersect</span><span
 class="p">(</span><span class="n">a</span><span class="p">,</span><span
 class="n">b</span><span class="p">)</span>
           <span class="k">ccall</span><span
 class="p">(:</span><span class="n">jl_breakpoint</span><span class="p">,</span> <span
 class="n">Void</span><span class="p">,</span> <span class="p">(</span><span
 class="kt">Any</span><span class="p">,),</span> <span class="n">nothing</span><span
 class="p">)</span>
           <span class="n">typeintersect</span><span
 class="p">(</span><span class="n">a</span><span class="p">,</span> <span
 class="n">b</span><span class="p">)</span>
       <span class="k">end</span>
</pre>
</div>
</div>
<p>and then set a breakpoint in <code class="docutils literal"><span
 class="pre">jl_breakpoint</span></code>. Once this breakpoint
gets triggered, you can set breakpoints in other functions.</p>
<p>As a warm-up, try the following:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">myintersect</span><span class="p">(</span><span
 class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span
 class="p">,</span><span class="kt">Float64</span><span class="p">},</span> <span
 class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span
 class="p">,</span><span class="n">Real</span><span class="p">})</span>
</pre>
</div>
</div>
<p>Set a breakpoint in <code class="docutils literal"><span class="pre">intersect_tuple</span></code>
and continue until it enters this function. You should be able to see
something like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">Breakpoint</span> <span class="mi">2</span><span
 class="p">,</span> <span class="n">intersect_tuple</span> <span
 class="p">(</span><span class="n">a</span><span class="o">=</span><span
 class="mh">0x7ffdf7409150</span><span class="p">,</span> <span
 class="n">b</span><span class="o">=</span><span class="mh">0x7ffdf74091b0</span><span
 class="p">,</span> <span class="n">penv</span><span class="o">=</span><span
 class="mh">0x7fffffffcc90</span><span class="p">,</span> <span
 class="n">eqc</span><span class="o">=</span><span class="mh">0x7fffffffcc70</span><span
 class="p">,</span> <span class="n">var</span><span class="o">=</span><span
 class="n">covariant</span><span class="p">)</span> <span class="n">at</span> <span
 class="n">jltypes</span><span class="o">.</span><span class="n">c</span><span
 class="p">:</span><span class="mi">405</span>
<span class="mi">405</span>     <span class="p">{</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span
 class="n">call</span> <span class="n">jl_</span><span class="p">(</span><span
 class="n">a</span><span class="p">)</span>
<span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span
 class="p">,</span> <span class="kt">Float64</span><span class="p">}</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span
 class="n">call</span> <span class="n">jl_</span><span class="p">(</span><span
 class="n">b</span><span class="p">)</span>
<span class="n">Tuple</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span> <span class="n">Real</span><span class="p">}</span>
</pre>
</div>
</div>
<p>The <code class="docutils literal"><span class="pre">var</span></code>
argument is either <code class="docutils literal"><span class="pre">covariant</span></code>
or <code class="docutils literal"><span class="pre">invariant</span></code>,
the
latter being used if you’re matching the type parameters of
<code class="docutils literal"><span class="pre">Array{T1}</span></code>
against <code class="docutils literal"><span class="pre">Array{T2}</span></code>.
The other two inputs to this
function (<code class="docutils literal"><span class="pre">penv</span></code>
and <code class="docutils literal"><span class="pre">eqc</span></code>)
may be currently mysterious, but we’ll
discuss them in a moment. For now, step through the code until you
get into the loop over the different entries in the tuple types <code
 class="docutils literal"><span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">b</span></code>.
The key call is:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">ce</span> <span class="o">=</span> <span class="n">jl_type_intersect</span><span
 class="p">(</span><span class="n">ae</span><span class="p">,</span><span
 class="n">be</span><span class="p">,</span><span class="n">penv</span><span
 class="p">,</span><span class="n">eqc</span><span class="p">,</span><span
 class="n">var</span><span class="p">);</span>
</pre>
</div>
</div>
<p>which, if you examine <code class="docutils literal"><span
 class="pre">ae</span></code>, <code class="docutils literal"><span
 class="pre">be</span></code>, and <code class="docutils literal"><span
 class="pre">ce</span></code>, you’ll see is just
type intersection performed on these entries.</p>
<p>We can make it more interesting by trying a more complex case:</p>
<div class="highlight-julia">
<div class="highlight">
<pre>julia&gt; T = TypeVar(:T, true)<br>T<br><br>julia&gt; myintersect(Tuple{Array{T}, T}, Tuple{Array{Int,2}, Int8})<br><br>Breakpoint 1, jl_breakpoint (v=0x7ffdf35e8010) at builtins.c:1559<br>1559    {<br>(gdb) b intersect_tuple<br>Breakpoint 3 at 0x7ffff6dcb07d: file jltypes.c, line 405.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 3, intersect_tuple (a=0x7ffdf74d7a90, b=0x7ffdf74d7af0, penv=0x7fffffffcc90, eqc=0x7fffffffcc70, var=covariant) at jltypes.c:405<br>405     {<br>(gdb) call jl_(a)<br>Tuple{Array{＃T&lt;:Any, N&lt;:Any}, ＃T&lt;:Any}<br>(gdb) call jl_(b)<br>Tuple{Array{Int64, 2}, Int8}<br></pre>
</div>
</div>
<p>Let’s watch how this bound <code
 class="xref jl jl-obj docutils literal"><span class="pre">TypeVar</span></code>
gets handled. To follow this,
you’ll need to examine the variables <code class="docutils literal"><span
 class="pre">penv</span></code> and <code class="docutils literal"><span
 class="pre">eqc</span></code>, which are
defined as:</p>
<div class="highlight-c">
<div class="highlight">
<pre><span class="k">typedef</span> <span class="k">struct</span> <span
 class="p">{</span>
    <span class="kt">jl_value_t</span> <span
 class="o">**</span><span class="n">data</span><span class="p">;</span>
    <span
 class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
    <span
 class="kt">jl_svec_t</span> <span class="o">*</span><span class="n">tvars</span><span
 class="p">;</span>
<span class="p">}</span> <span class="kt">cenv_t</span><span class="p">;</span>
</pre>
</div>
</div>
<p>These start out empty (with <code class="docutils literal"><span
 class="pre">penv-&gt;n</span> <span class="pre">==</span> <span
 class="pre">eqc-&gt;n</span> <span class="pre">==</span> <span
 class="pre">0</span></code>). Once we get
into the loop and make the first call to <code class="docutils literal"><span
 class="pre">jl_type_intersect</span></code>,
<code class="docutils literal"><span class="pre">eqc</span></code>
(which stands for “equality constraints”) has the following
value:</p>
<div class="highlight-julia">
<div class="highlight">
<pre>(gdb) p eqc-&gt;n<br>$4 = 2<br>(gdb) call jl_(eqc-&gt;data[0])<br>＃T&lt;:Any<br>(gdb) call jl_(eqc-&gt;data[1])<br>Int64<br></pre>
</div>
</div>
<p>This is just a <code class="docutils literal"><span class="pre">var</span></code>,
<code class="docutils literal"><span class="pre">value</span></code>
list of pairs, indicating that <code class="docutils literal"><span
 class="pre">T</span></code>
now has the value <code class="docutils literal"><span class="pre">Int64</span></code>.
If you now allow <code class="docutils literal"><span class="pre">intersect_tuple</span></code>
to
finish and keep progressing, you’ll eventually get to
<code class="docutils literal"><span class="pre">type_intersection_matching</span></code>.
This function contains a call to
<code class="docutils literal"><span class="pre">solve_tvar_constraints</span></code>.
Roughly speaking, <code class="docutils literal"><span class="pre">eqc</span></code>
defines <code class="docutils literal"><span class="pre">T</span> <span
 class="pre">=</span>
<span class="pre">Int64</span></code>, but <code
 class="docutils literal"><span class="pre">env</span></code> defines
it as <code class="docutils literal"><span class="pre">Int8</span></code>;
this conflict is detected
in <code class="docutils literal"><span class="pre">solve_tvar_constraints</span></code>
and the resulting return is
<code class="docutils literal"><span class="pre">jl_bottom_type</span></code>,
aka <code class="docutils literal"><span class="pre">Union{}</span></code>.</p>
</div>
<div class="section" id="subtyping-and-method-sorting">
<h2>Subtyping and method sorting<a class="headerlink"
 href="#subtyping-and-method-sorting" title="Permalink to this headline">¶</a></h2>
<p>Armed with this knowledge, you may find yourself surprised by the
following:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">},</span><span class="kt">Float64</span><span
 class="p">},</span> <span class="n">Tuple</span><span class="p">{</span><span
 class="n">Array</span><span class="p">{</span><span class="n">T</span><span
 class="p">},</span><span class="n">T</span><span class="p">})</span>
<span class="n">Union</span><span class="p">{}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Tuple</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="kt">Int</span><span class="p">},</span><span class="kt">Float64</span><span
 class="p">}</span> <span class="o">&lt;:</span> <span class="n">Tuple</span><span
 class="p">{</span><span class="n">Array</span><span class="p">{</span><span
 class="n">T</span><span class="p">},</span><span class="n">T</span><span
 class="p">}</span>
<span class="n">true</span>
</pre>
</div>
</div>
<p>where <code class="docutils literal"><span class="pre">T</span></code>
is a bound <code class="xref jl jl-obj docutils literal"><span
 class="pre">TypeVar</span></code>. In other words, <code
 class="docutils literal"><span class="pre">A</span> <span class="pre">&lt;:</span>
<span class="pre">B</span></code> does
not imply that <code class="docutils literal"><span class="pre">typeintersect(A,</span>
<span class="pre">B)</span> <span class="pre">==</span> <span
 class="pre">A</span></code>. A little bit of digging
reveals the reason why: <code class="docutils literal"><span
 class="pre">jl_subtype_le</span></code> does not use the <code
 class="docutils literal"><span class="pre">cenv_t</span></code>
constraints that we just saw in <code class="docutils literal"><span
 class="pre">typeintersect</span></code>.</p>
<p><code class="docutils literal"><span class="pre">jltypes.c</span></code>
contains three closely related collections of functions
for testing how types <code class="docutils literal"><span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">b</span></code>
are ordered:</p>
<ul class="simple">
  <li>The <code class="docutils literal"><span class="pre">subtype</span></code>
functions implement <code class="docutils literal"><span class="pre">a</span>
    <span class="pre">&lt;:</span> <span class="pre">b</span></code>.
Among other uses, they
serve in matching function arguments against method signatures in
the function cache.</li>
  <li>The <code class="docutils literal"><span class="pre">type_morespecific</span></code>
functions are used for imposing a partial
order on functions in method tables (from most-to-least
specific). Note that <code class="docutils literal"><span class="pre">jl_type_morespecific(a,b,0)</span></code>
really means “is <code class="docutils literal"><span class="pre">a</span></code>
at least as specific as <code class="docutils literal"><span
 class="pre">b</span></code>?” and not “is <code
 class="docutils literal"><span class="pre">a</span></code> strictly
more specific
than <code class="docutils literal"><span class="pre">b</span></code>?”</li>
  <li>The <code class="docutils literal"><span class="pre">type_match</span></code>
functions are similar to <code class="docutils literal"><span
 class="pre">type_morespecific</span></code>, but
additionally accept (and employ) an environment to constrain
typevars. The related <code class="docutils literal"><span class="pre">type_match_morespecific</span></code>
functions call
    <code class="docutils literal"><span class="pre">type_match</span></code>
with an argument <code class="docutils literal"><span class="pre">morespecific=1</span></code></li>
</ul>
<p>All three of these take an argument, <code class="docutils literal"><span
 class="pre">invariant</span></code>, which is set to 1 when
comparing type parameters and otherwise is 0.</p>
<p>The rules for these are somewhat different. <code
 class="docutils literal"><span class="pre">subtype</span></code> is
sensitive
to the number arguments, but <code class="docutils literal"><span
 class="pre">type_morespecific</span></code> may not be. In
particular, <code class="docutils literal"><span class="pre">Tuple{Int,AbstractFloat}</span></code>
is more specific than
<code class="docutils literal"><span class="pre">Tuple{Integer}</span></code>,
even though it is not a subtype. (Of
<code class="docutils literal"><span class="pre">Tuple{Int,AbstractFloat}</span></code>
and <code class="docutils literal"><span class="pre">Tuple{Integer,Float64}</span></code>,
neither
is more specific than the other.) Likewise, <code
 class="docutils literal"><span class="pre">Tuple{Int,Vararg{Int}}</span></code>
is not a subtype of <code class="docutils literal"><span class="pre">Tuple{Integer}</span></code>,
but it is considered
more specific. However, <code class="docutils literal"><span
 class="pre">morespecific</span></code> does get a bonus for length:
in particular, <code class="docutils literal"><span class="pre">Tuple{Int,Int}</span></code>
is more specific than
<code class="docutils literal"><span class="pre">Tuple{Int,Vararg{Int}}</span></code>.</p>
<p>If you’re debugging how methods get sorted, it can be convenient to
define the function:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">args_morespecific</span><span class="p">(</span><span
 class="n">a</span><span class="p">,</span> <span class="n">b</span><span
 class="p">)</span> <span class="o">=</span> <span class="k">ccall</span><span
 class="p">(:</span><span class="n">jl_args_morespecific</span><span
 class="p">,</span> <span class="n">Cint</span><span class="p">,</span> <span
 class="p">(</span><span class="kt">Any</span><span class="p">,</span><span
 class="kt">Any</span><span class="p">),</span> <span class="n">a</span><span
 class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre>
</div>
</div>
<p>which allows you to test whether arg-tuple <code
 class="docutils literal"><span class="pre">a</span></code> is more
specific than
arg-tuple <code class="docutils literal"><span class="pre">b</span></code>.</p>
</div>
</div>
</div>
<footer> </footer>
<div class="rst-footer-buttons" role="navigation"
 aria-label="footer navigation"> <a href="object.html"
 class="btn btn-neutral float-right"
 title="Memory layout of Julia Objects">Next </a> <a href="ast.html"
 class="btn btn-neutral" title="Julia ASTs"> Previous</a> </div>
<hr>
<div role="contentinfo">
<p> </p>
</div>
<a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a>
provided by <a href="https://readthedocs.org">Read the Docs</a> </div>
<div class="wy-nav-content"> </div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
<script type="text/javascript" src="../_static/jquery.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript"
 src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../_static/js/theme.js"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
</body>
</html>
