<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]--><!--[if gt IE 8]><!--><!--<![endif]-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Constructors — Julia Language 0.4.3 documentation</title>
  <link
 href="https://fonts.googleapis.com/css?family=Lato:400,700%7CRoboto+Slab:400,700%7CInconsolata:400,700"
 rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="top" title="Julia Language 0.4.3 documentation"
 href="../index.html">
  <link rel="next" title="Conversion and Promotion"
 href="conversion-and-promotion.html">
  <link rel="prev" title="Methods" href="methods.html">
  <script
 src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<div class="wy-nav-content">
<div class="rst-content">
<div role="main" class="document">
<div class="section" id="constructors">
<h1>コンストラクタ</h1>
<p>Constructors <a class="footnote-reference" href="#id2" id="id1">[1]</a>
are functions that create new objects — specifically,
instances of <a class="reference internal"
 href="types.html#man-composite-types"><span>Composite Types</span></a>.
In Julia,
type objects also serve as constructor functions: they create new
instances of themselves when applied to an argument tuple as a
function.
This much was already mentioned briefly when composite types were
introduced. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> Foo</span>
  <span
 class="n">bar</span>
  <span class="n">baz</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span> <span
 class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span
 class="mi">1</span><span class="p">,</span><span class="mi">2</span><span
 class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span
 class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span
 class="o">.</span><span class="n">bar</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span
 class="o">.</span><span class="n">baz</span>
<span class="mi">2</span>
</pre>
</div>
</div>
<p>For many types, forming new objects by binding their field values
together is all that is ever needed to create instances. There are,
however, cases where more functionality is required when creating
composite objects. Sometimes invariants must be enforced, either by
checking arguments or by transforming them. <a
 class="reference external"
 href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29">Recursive
data
structures</a>,
especially those that may be self-referential, often cannot be
constructed cleanly without first being created in an incomplete state
and then altered programmatically to be made whole, as a separate step
from object creation. Sometimes, it’s just convenient to be able to
construct objects with fewer or different types of parameters than they
have fields. Julia’s system for object construction addresses all of
these cases and more.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
  <colgroup><col class="label"><col></colgroup> <tbody valign="top">
    <tr>
      <td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
      <td>Nomenclature: while the term “constructor” generally refers
to
the entire function which constructs objects of a type, it is common to
abuse terminology slightly and refer to specific constructor methods as
“constructors”. In such situations, it is generally clear from context
that the term is used to mean “constructor method” rather than
“constructor function”, especially as it is often used in the sense of
singling out a particular method of the constructor from all of the
others.</td>
    </tr>
  </tbody>
</table>
<div class="section" id="outer-constructor-methods">
<h2>外側のコンストラクタ・メソッド</h2>
<p>A constructor is just like any other function in Julia in that its
overall behavior is defined by the combined behavior of its methods.
Accordingly, you can add functionality to a constructor by simply
defining new methods. For example, let’s say you want to add a
constructor method for <code class="docutils literal"><span class="pre">Foo</span></code>
objects that takes only one argument and
uses the given value for both the <code class="docutils literal"><span
 class="pre">bar</span></code> and <code class="docutils literal"><span
 class="pre">baz</span></code> fields. This is
simple:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">Foo</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span><span
 class="n">x</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Foo</span><span
 class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span
 class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre>
</div>
</div>
<p>You could also add a zero-argument <code class="docutils literal"><span
 class="pre">Foo</span></code> constructor method that
supplies default values for both of the <code class="docutils literal"><span
 class="pre">bar</span></code> and <code class="docutils literal"><span
 class="pre">baz</span></code> fields:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">Foo</span><span class="p">()</span> <span class="o">=</span> <span
 class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Foo</span><span
 class="p">()</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span
 class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre>
</div>
</div>
<p>Here the zero-argument constructor method calls the single-argument
constructor method, which in turn calls the automatically provided
two-argument constructor method. For reasons that will become clear
very
shortly, additional constructor methods declared as normal methods like
this are called <em>outer</em> constructor methods. Outer constructor
methods
can only ever create a new instance by calling another constructor
method, such as the automatically provided default ones.</p>
</div>
<div class="section" id="inner-constructor-methods">
<h2>内側のコンストラクタ・メソッド</h2>
<p>While outer constructor methods succeed in addressing the problem of
providing additional convenience methods for constructing objects, they
fail to address the other two use cases mentioned in the introduction
of
this chapter: enforcing invariants, and allowing construction of
self-referential objects. For these problems, one needs <em>inner</em>
constructor methods. An inner constructor method is much like an outer
constructor method, with two differences:</p>
<ol class="arabic simple">
  <li>It is declared inside the block of a type declaration, rather
than
outside of it like normal methods.</li>
  <li>It has access to a special locally existent function called <code
 class="docutils literal"><span class="pre">new</span></code>
that creates objects of the block’s type.</li>
</ol>
<p>For example, suppose one wants to declare a type that holds a pair
of
real numbers, subject to the constraint that the first number is
not greater than the second one. One could declare it like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> OrderedPair</span>
  <span
 class="n">x</span><span class="p">::</span><span class="n">Real</span>
  <span
 class="n">y</span><span class="p">::</span><span class="n">Real</span>

  <span
 class="n">OrderedPair</span><span class="p">(</span><span class="n">x</span><span
 class="p">,</span><span class="n">y</span><span class="p">)</span> <span
 class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span
 class="n">y</span> <span class="o">?</span> <span class="nb">error</span><span
 class="p">(</span><span class="s">"out of order"</span><span class="p">)</span> <span
 class="p">:</span> <span class="nb">new</span><span class="p">(</span><span
 class="n">x</span><span class="p">,</span><span class="n">y</span><span
 class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>Now <code class="docutils literal"><span class="pre">OrderedPair</span></code>
objects can only be constructed such that
<code class="docutils literal"><span class="pre">x</span> <span
 class="pre">&lt;=</span> <span class="pre">y</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">OrderedPair</span><span class="p">(</span><span class="mi">1</span><span
 class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">OrderedPair</span><span class="p">(</span><span
 class="mi">1</span><span class="p">,</span><span class="mi">2</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">OrderedPair</span><span
 class="p">(</span><span class="mi">2</span><span class="p">,</span><span
 class="mi">1</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">out</span> <span
 class="n">of</span> <span class="n">order</span>
 <span class="k">in</span> <span
 class="n">call</span> <span class="n">at</span> <span class="n">none</span><span
 class="p">:</span><span class="mi">5</span>
</pre>
</div>
</div>
<p>You can still reach in and directly change the field values to
violate
this invariant, but messing around with an object’s internals uninvited
is
considered poor form. You (or someone else) can also provide additional
outer constructor methods at any later point, but once a type is
declared, there is no way to add more inner constructor methods. Since
outer constructor methods can only create objects by calling other
constructor methods, ultimately, some inner constructor must be called
to create an object. This guarantees that all objects of the declared
type must come into existence by a call to one of the inner constructor
methods provided with the type, thereby giving some degree of
enforcement of a type’s invariants.</p>
<p>Of course, if the type is declared as <code class="docutils literal"><span
 class="pre">immutable</span></code>, then its
constructor-provided invariants are fully enforced. This is an
important
consideration when deciding whether a type should be immutable.</p>
<p>If any inner constructor method is defined, no default constructor
method is provided: it is presumed that you have supplied yourself with
all the inner constructors you need. The default constructor is
equivalent to writing your own inner constructor method that takes all
of the object’s fields as parameters (constrained to be of the correct
type, if the corresponding field has a type), and passes them to
<code class="docutils literal"><span class="pre">new</span></code>,
returning the resulting object:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> Foo</span>
  <span
 class="n">bar</span>
  <span class="n">baz</span>

  <span class="n">Foo</span><span
 class="p">(</span><span class="n">bar</span><span class="p">,</span><span
 class="n">baz</span><span class="p">)</span> <span class="o">=</span> <span
 class="nb">new</span><span class="p">(</span><span class="n">bar</span><span
 class="p">,</span><span class="n">baz</span><span class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>This declaration has the same effect as the earlier definition of
the
<code class="docutils literal"><span class="pre">Foo</span></code> type
without an explicit inner constructor method. The following
two types are equivalent — one with a default constructor, the other
with an explicit constructor:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> T1</span>
  <span
 class="n">x</span><span class="p">::</span><span class="kt">Int64</span>
<span class="k">end</span>

<span class="k">type</span><span class="nc"> T2</span>
  <span
 class="n">x</span><span class="p">::</span><span class="kt">Int64</span>
  <span
 class="n">T2</span><span class="p">(</span><span class="n">x</span><span
 class="p">)</span> <span class="o">=</span> <span class="nb">new</span><span
 class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T1</span><span
 class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T2</span><span
 class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T1</span><span
 class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span
 class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T2</span><span
 class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span
 class="p">)</span>
</pre>
</div>
</div>
<p>It is considered good form to provide as few inner constructor
methods
as possible: only those taking all arguments explicitly and enforcing
essential error checking and transformation. Additional convenience
constructor methods, supplying default values or auxiliary
transformations, should be provided as outer constructors that call the
inner constructors to do the heavy lifting. This separation is
typically
quite natural.</p>
</div>
<div class="section" id="incomplete-initialization">
<div id="gt-src-c" class="g-unit">
<div id="gt-src-p"> </div>
</div>
<div id="gt-res-content" class="almost_half_cell">
<div dir="ltr" style="">
<h2><span id="result_box" class="short_text" lang="ja"><span>不完全な</span><span
 class="">初期化</span></span></h2>
</div>
</div>
<p>The final problem which has still not been addressed is construction
of
self-referential objects, or more generally, recursive data structures.
Since the fundamental difficulty may not be immediately obvious, let us
briefly explain it. Consider the following recursive type declaration:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> SelfReferential</span>
  <span
 class="n">obj</span><span class="p">::</span><span class="n">SelfReferential</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>This type may appear innocuous enough, until one considers how to
construct an instance of it. If <code class="docutils literal"><span
 class="pre">a</span></code> is an instance of
<code class="docutils literal"><span class="pre">SelfReferential</span></code>,
then a second instance can be created by the call:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">b</span> <span class="o">=</span> <span class="n">SelfReferential</span><span
 class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre>
</div>
</div>
<p>But how does one construct the first instance when no instance
exists to
provide as a valid value for its <code class="docutils literal"><span
 class="pre">obj</span></code> field? The only solution is to
allow creating an incompletely initialized instance of
<code class="docutils literal"><span class="pre">SelfReferential</span></code>
with an unassigned <code class="docutils literal"><span class="pre">obj</span></code>
field, and using that
incomplete instance as a valid value for the <code
 class="docutils literal"><span class="pre">obj</span></code> field of
another
instance, such as, for example, itself.</p>
<p>To allow for the creation of incompletely initialized objects, Julia
allows the <code class="docutils literal"><span class="pre">new</span></code>
function to be called with fewer than the number of
fields that the type has, returning an object with the unspecified
fields uninitialized. The inner constructor method can then use the
incomplete object, finishing its initialization before returning it.
Here, for example, we take another crack at defining the
<code class="docutils literal"><span class="pre">SelfReferential</span></code>
type, with a zero-argument inner constructor
returning instances having <code class="docutils literal"><span
 class="pre">obj</span></code> fields pointing to themselves:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> SelfReferential</span>
  <span
 class="n">obj</span><span class="p">::</span><span class="n">SelfReferential</span>

  <span
 class="n">SelfReferential</span><span class="p">()</span> <span
 class="o">=</span> <span class="p">(</span><span class="n">x</span> <span
 class="o">=</span> <span class="nb">new</span><span class="p">();</span> <span
 class="n">x</span><span class="o">.</span><span class="n">obj</span> <span
 class="o">=</span> <span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>We can verify that this constructor works and constructs objects
that
are, in fact, self-referential:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">x</span> <span class="o">=</span> <span class="n">SelfReferential</span><span
 class="p">();</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span> <span
 class="n">x</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span> <span
 class="n">x</span><span class="o">.</span><span class="n">obj</span><span
 class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span> <span
 class="n">x</span><span class="o">.</span><span class="n">obj</span><span
 class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="n">true</span>
</pre>
</div>
</div>
<p>Although it is generally a good idea to return a fully initialized
object from an inner constructor, incompletely initialized objects can
be returned:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> Incomplete</span>
         <span
 class="n">xx</span>
         <span class="n">Incomplete</span><span
 class="p">()</span> <span class="o">=</span> <span class="nb">new</span><span
 class="p">()</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">z</span> <span
 class="o">=</span> <span class="n">Incomplete</span><span class="p">();</span>
</pre>
</div>
</div>
<p>While you are allowed to create objects with uninitialized fields,
any
access to an uninitialized reference is an immediate error:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">z</span><span class="o">.</span><span class="n">xx</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">UndefRefError</span><span
 class="p">:</span> <span class="n">access</span> <span class="n">to</span> <span
 class="n">undefined</span> <span class="n">reference</span>
</pre>
</div>
</div>
<p>This avoids the need to continually check for <code
 class="docutils literal"><span class="pre">null</span></code> values.
However, not all object fields are references. Julia considers some
types to be “plain data”, meaning all of their data is self-contained
and does not reference other objects. The plain data types consist of
bits
types (e.g. <code class="docutils literal"><span class="pre">Int</span></code>)
and immutable structs of other plain data types.
The initial contents of a plain data type is undefined:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> HasPlain</span>
         <span
 class="n">n</span><span class="p">::</span><span class="kt">Int</span>
         <span
 class="n">HasPlain</span><span class="p">()</span> <span class="o">=</span> <span
 class="nb">new</span><span class="p">()</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">HasPlain</span><span
 class="p">()</span>
<span class="n">HasPlain</span><span class="p">(</span><span class="mi">438103441441</span><span
 class="p">)</span>
</pre>
</div>
</div>
<p>Arrays of plain data types exhibit the same behavior.</p>
<p>You can pass incomplete objects to other functions from inner
constructors to
delegate their completion:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> Lazy</span>
  <span
 class="n">xx</span>

  <span class="n">Lazy</span><span class="p">(</span><span
 class="n">v</span><span class="p">)</span> <span class="o">=</span> <span
 class="n">complete_me</span><span class="p">(</span><span class="nb">new</span><span
 class="p">(),</span> <span class="n">v</span><span class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>As with incomplete objects returned from constructors, if
<code class="docutils literal"><span class="pre">complete_me</span></code>
or any of its callees try to access the <code class="docutils literal"><span
 class="pre">xx</span></code> field of
the <code class="docutils literal"><span class="pre">Lazy</span></code>
object before it has been initialized, an error will be
thrown immediately.</p>
</div>
<div class="section" id="parametric-constructors">
<h2>パラメトリックコンストラクタ<a class="headerlink" href="#parametric-constructors"
 title="Permalink to this headline"></a></h2>
<p>Parametric types add a few wrinkles to the constructor story. Recall
from <a class="reference internal"
 href="types.html#man-parametric-types"><span>Parametric Types</span></a>
that, by default,
instances of parametric composite types can be constructed either with
explicitly given type parameters or with type parameters implied by the
types of the arguments given to the constructor. Here are some examples:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span
 class="p">}</span>
         <span class="n">x</span><span class="p">::</span><span
 class="n">T</span>
         <span class="n">y</span><span class="p">::</span><span
 class="n">T</span>
       <span class="k">end</span>

<span class="c">## implicit T ##</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">(</span><span class="mi">1</span><span class="p">,</span><span
 class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">}(</span><span class="mi">1</span><span class="p">,</span><span
 class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">2.5</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">(</span><span class="mi">1</span><span class="p">,</span><span
 class="mf">2.5</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span
 class="p">:</span> <span class="sb">`convert`</span> <span class="n">has</span> <span
 class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span
 class="nb">convert</span><span class="p">(::</span><span class="n">Type</span><span
 class="p">{</span><span class="n">Point</span><span class="p">{</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span
 class="p">}},</span> <span class="p">::</span><span class="kt">Int64</span><span
 class="p">,</span> <span class="p">::</span><span class="kt">Float64</span><span
 class="p">)</span>
<span class="n">This</span> <span class="n">may</span> <span class="n">have</span> <span
 class="n">arisen</span> <span class="n">from</span> <span class="n">a</span> <span
 class="n">call</span> <span class="n">to</span> <span class="n">the</span> <span
 class="n">constructor</span> <span class="n">Point</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(</span><span class="o">...</span><span
 class="p">),</span>
<span class="n">since</span> <span class="k">type</span><span class="nc"> constructors</span> <span
 class="n">fall</span> <span class="n">back</span> <span class="n">to</span> <span
 class="nb">convert</span> <span class="n">methods</span><span class="o">.</span>
<span class="n">Closest</span> <span class="n">candidates</span> <span
 class="n">are</span><span class="p">:</span>
  <span class="n">Point</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(::</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="n">Real</span><span class="p">,</span> <span
 class="o">!</span><span class="n">Matched</span><span class="p">::</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span
 class="p">)</span>
  <span class="n">call</span><span class="p">{</span><span
 class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span
 class="p">{</span><span class="n">T</span><span class="p">},</span> <span
 class="p">::</span><span class="kt">Any</span><span class="p">)</span>
  <span
 class="nb">convert</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span
 class="n">T</span><span class="p">},</span> <span class="o">!</span><span
 class="n">Matched</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span>
 <span class="k">in</span> <span class="n">call</span> <span
 class="n">at</span> <span class="n">essentials</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">57</span>

<span class="c">## explicit T ##</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span
 class="mi">1</span><span class="p">,</span><span class="mi">2</span><span
 class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">}(</span><span class="mi">1</span><span class="p">,</span><span
 class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span
 class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span
 class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">InexactError</span><span
 class="p">()</span>
 <span class="k">in</span> <span class="n">call</span> <span
 class="n">at</span> <span class="n">none</span><span class="p">:</span><span
 class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span
 class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span
 class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span
 class="mi">1</span><span class="p">,</span><span class="mi">2</span><span
 class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">2.0</span><span class="p">)</span>
</pre>
</div>
</div>
<p>As you can see, for constructor calls with explicit type parameters,
the
arguments are converted to the implied field types: <code
 class="docutils literal"><span class="pre">Point{Int64}(1,2)</span></code>
works, but <code class="docutils literal"><span class="pre">Point{Int64}(1.0,2.5)</span></code>
raises an
<code class="docutils literal"><span class="pre">InexactError</span></code>
when converting <code class="docutils literal"><span class="pre">2.5</span></code>
to <code class="docutils literal"><span class="pre">Int64</span></code>.
When the type is implied by the
arguments to the constructor call, as in <code class="docutils literal"><span
 class="pre">Point(1,2)</span></code>, then the types
of the arguments must agree — otherwise the <code
 class="docutils literal"><span class="pre">T</span></code> cannot be
determined —
but any pair of real arguments with matching type may be given to the
generic <code class="docutils literal"><span class="pre">Point</span></code>
constructor.</p>
<p>What’s really going on here is that <code class="docutils literal"><span
 class="pre">Point</span></code>, <code class="docutils literal"><span
 class="pre">Point{Float64}</span></code> and
<code class="docutils literal"><span class="pre">Point{Int64}</span></code>
are all different constructor functions. In fact,
<code class="docutils literal"><span class="pre">Point{T}</span></code>
is a distinct constructor function for each type <code
 class="docutils literal"><span class="pre">T</span></code>.
Without any explicitly provided inner constructors, the declaration of
the composite type <code class="docutils literal"><span class="pre">Point{T&lt;:Real}</span></code>
automatically provides an inner
constructor, <code class="docutils literal"><span class="pre">Point{T}</span></code>,
for each possible type <code class="docutils literal"><span class="pre">T&lt;:Real</span></code>,
that
behaves just like non-parametric default inner constructors do. It also
provides a single general outer <code class="docutils literal"><span
 class="pre">Point</span></code> constructor that takes pairs
of real arguments, which must be of the same type. This automatic
provision of constructors is equivalent to the following explicit
declaration:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> Point</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}</span>
  <span class="n">x</span><span
 class="p">::</span><span class="n">T</span>
  <span class="n">y</span><span
 class="p">::</span><span class="n">T</span>

  <span class="n">Point</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span><span
 class="n">y</span><span class="p">)</span> <span class="o">=</span> <span
 class="nb">new</span><span class="p">(</span><span class="n">x</span><span
 class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">Point</span><span class="p">{</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span
 class="n">x</span><span class="p">::</span><span class="n">T</span><span
 class="p">,</span> <span class="n">y</span><span class="p">::</span><span
 class="n">T</span><span class="p">)</span> <span class="o">=</span> <span
 class="n">Point</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(</span><span class="n">x</span><span class="p">,</span><span
 class="n">y</span><span class="p">)</span>
</pre>
</div>
</div>
<p>Some features of parametric constructor definitions at work here
deserve
comment. First, inner constructor declarations always define methods of
<code class="docutils literal"><span class="pre">Point{T}</span></code>
rather than methods of the general <code class="docutils literal"><span
 class="pre">Point</span></code> constructor
function. Since <code class="docutils literal"><span class="pre">Point</span></code>
is not a concrete type, it makes no sense for
it to even have inner constructor methods at all. Thus, the inner
method
declaration <code class="docutils literal"><span class="pre">Point(x,y)</span>
<span class="pre">=</span> <span class="pre">new(x,y)</span></code>
provides an inner
constructor method for each value of <code class="docutils literal"><span
 class="pre">T</span></code>. It is this method
declaration that defines the behavior of constructor calls with
explicit
type parameters like <code class="docutils literal"><span class="pre">Point{Int64}(1,2)</span></code>
and
<code class="docutils literal"><span class="pre">Point{Float64}(1.0,2.0)</span></code>.
The outer constructor declaration, on the
other hand, defines a method for the general <code
 class="docutils literal"><span class="pre">Point</span></code>
constructor which
only applies to pairs of values of the same real type. This declaration
makes constructor calls without explicit type parameters, like
<code class="docutils literal"><span class="pre">Point(1,2)</span></code>
and <code class="docutils literal"><span class="pre">Point(1.0,2.5)</span></code>,
work. Since the method
declaration restricts the arguments to being of the same type, calls
like <code class="docutils literal"><span class="pre">Point(1,2.5)</span></code>,
with arguments of different types, result in “no
method” errors.</p>
<p>Suppose we wanted to make the constructor call <code
 class="docutils literal"><span class="pre">Point(1,2.5)</span></code>
work by
“promoting” the integer value <code class="docutils literal"><span
 class="pre">1</span></code> to the floating-point value <code
 class="docutils literal"><span class="pre">1.0</span></code>.
The simplest way to achieve this is to define the following additional
outer constructor method:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Point</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="kt">Int64</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="kt">Float64</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">Point</span><span
 class="p">(</span><span class="nb">convert</span><span class="p">(</span><span
 class="kt">Float64</span><span class="p">,</span><span class="n">x</span><span
 class="p">),</span><span class="n">y</span><span class="p">);</span>
</pre>
</div>
</div>
<p>This method uses the <a class="reference internal"
 href="../stdlib/base.html#Base.convert" title="Base.convert"><code
 class="xref jl jl-func docutils literal"><span class="pre">convert()</span></code></a>
function to explicitly convert <code class="docutils literal"><span
 class="pre">x</span></code> to
<a class="reference internal" href="../stdlib/numbers.html#Base.Float64"
 title="Base.Float64"><code class="xref jl jl-class docutils literal"><span
 class="pre">Float64</span></code></a> and then delegates construction
to the general constructor
for the case where both arguments are <a class="reference internal"
 href="../stdlib/numbers.html#Base.Float64" title="Base.Float64"><code
 class="xref jl jl-class docutils literal"><span class="pre">Float64</span></code></a>.
With this method
definition what was previously a <a class="reference internal"
 href="../stdlib/base.html#Base.MethodError" title="Base.MethodError"><code
 class="xref jl jl-exc docutils literal"><span class="pre">MethodError</span></code></a>
now successfully
creates a point of type <code class="docutils literal"><span
 class="pre">Point{Float64}</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Point</span><span class="p">(</span><span class="mi">1</span><span
 class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}</span>
</pre>
</div>
</div>
<p>However, other similar calls still don’t work:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span
 class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span
 class="p">:</span> <span class="sb">`convert`</span> <span class="n">has</span> <span
 class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span
 class="nb">convert</span><span class="p">(::</span><span class="n">Type</span><span
 class="p">{</span><span class="n">Point</span><span class="p">{</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span
 class="p">}},</span> <span class="p">::</span><span class="kt">Float64</span><span
 class="p">,</span> <span class="p">::</span><span class="kt">Int64</span><span
 class="p">)</span>
<span class="n">This</span> <span class="n">may</span> <span class="n">have</span> <span
 class="n">arisen</span> <span class="n">from</span> <span class="n">a</span> <span
 class="n">call</span> <span class="n">to</span> <span class="n">the</span> <span
 class="n">constructor</span> <span class="n">Point</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(</span><span class="o">...</span><span
 class="p">),</span>
<span class="n">since</span> <span class="k">type</span><span class="nc"> constructors</span> <span
 class="n">fall</span> <span class="n">back</span> <span class="n">to</span> <span
 class="nb">convert</span> <span class="n">methods</span><span class="o">.</span>
<span class="n">Closest</span> <span class="n">candidates</span> <span
 class="n">are</span><span class="p">:</span>
  <span class="n">Point</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">}(::</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="n">Real</span><span class="p">,</span> <span
 class="o">!</span><span class="n">Matched</span><span class="p">::</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span
 class="p">)</span>
  <span class="n">call</span><span class="p">{</span><span
 class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span
 class="p">{</span><span class="n">T</span><span class="p">},</span> <span
 class="p">::</span><span class="kt">Any</span><span class="p">)</span>
  <span
 class="nb">convert</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span
 class="n">T</span><span class="p">},</span> <span class="o">!</span><span
 class="n">Matched</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span>
  <span class="o">...</span>
 <span class="k">in</span> <span
 class="n">call</span> <span class="n">at</span> <span class="n">essentials</span><span
 class="o">.</span><span class="n">jl</span><span class="p">:</span><span
 class="mi">57</span>
</pre>
</div>
</div>
<p>For a much more general way of making all such calls work sensibly,
see
<a class="reference internal"
 href="conversion-and-promotion.html#man-conversion-and-promotion"><span>Conversion
and Promotion</span></a>. At the risk
of spoiling the suspense, we can reveal here that all it takes is
the following outer method definition to make all calls to the general
<code class="docutils literal"><span class="pre">Point</span></code>
constructor work as one would expect:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Point</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Real</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="n">Real</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">Point</span><span
 class="p">(</span><span class="nb">promote</span><span class="p">(</span><span
 class="n">x</span><span class="p">,</span><span class="n">y</span><span
 class="p">)</span><span class="o">...</span><span class="p">);</span>
</pre>
</div>
</div>
<p>The <code class="docutils literal"><span class="pre">promote</span></code>
function converts all its arguments to a common type
— in this case <a class="reference internal"
 href="../stdlib/numbers.html#Base.Float64" title="Base.Float64"><code
 class="xref jl jl-class docutils literal"><span class="pre">Float64</span></code></a>.
With this method definition, the <code class="docutils literal"><span
 class="pre">Point</span></code>
constructor promotes its arguments the same way that numeric operators
like <a class="reference internal" href="../stdlib/math.html#Base.+"
 title="Base.+"><code class="xref jl jl-obj docutils literal"><span
 class="pre">+</span></code></a> do, and works for all kinds of real
numbers:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span
 class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.5</span><span class="p">,</span><span
 class="mf">2.0</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">(</span><span class="mi">1</span><span class="p">,</span><span
 class="mi">1</span><span class="o">//</span><span class="mi">2</span><span
 class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="n">Rational</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">}}(</span><span
 class="mi">1</span><span class="o">//</span><span class="mi">1</span><span
 class="p">,</span><span class="mi">1</span><span class="o">//</span><span
 class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span
 class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mi">1</span><span class="o">//</span><span class="mi">2</span><span
 class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span
 class="mf">0.5</span><span class="p">)</span>
</pre>
</div>
</div>
<p>Thus, while the implicit type parameter constructors provided by
default
in Julia are fairly strict, it is possible to make them behave in a
more
relaxed but sensible manner quite easily. Moreover, since constructors
can leverage all of the power of the type system, methods, and multiple
dispatch, defining sophisticated behavior is typically quite simple.</p>
</div>
<div class="section" id="case-study-rational">
<h2><span id="result_box" class="short_text" lang="ja"><span>ケーススタディ</span><span>：</span><span
 class="">理論的根拠</span></span><a class="headerlink"
 href="#case-study-rational" title="Permalink to this headline"></a></h2>
<p>Perhaps the best way to tie all these pieces together is to present
a
real world example of a parametric composite type and its constructor
methods. To that end, here is beginning of
<a class="reference external"
 href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>,
which implements Julia’s <a class="reference internal"
 href="complex-and-rational-numbers.html#man-rational-numbers"><span>Rational
Numbers</span></a>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">immutable</span> <span class="n">Rational</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Integer</span><span class="p">}</span> <span class="o">&lt;:</span> <span
 class="n">Real</span>
    <span class="n">num</span><span class="p">::</span><span
 class="n">T</span>
    <span class="n">den</span><span class="p">::</span><span
 class="n">T</span>

    <span class="k">function</span><span
 class="nf"> Rational</span><span class="p">(</span><span class="n">num</span><span
 class="p">::</span><span class="n">T</span><span class="p">,</span> <span
 class="n">den</span><span class="p">::</span><span class="n">T</span><span
 class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span
 class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span
 class="n">den</span> <span class="o">==</span> <span class="mi">0</span>
            <span
 class="nb">error</span><span class="p">(</span><span class="s">"invalid rational: 0//0"</span><span
 class="p">)</span>
        <span class="k">end</span>
        <span
 class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span
 class="p">(</span><span class="n">den</span><span class="p">,</span> <span
 class="n">num</span><span class="p">)</span>
        <span class="n">num</span> <span
 class="o">=</span> <span class="n">div</span><span class="p">(</span><span
 class="n">num</span><span class="p">,</span> <span class="n">g</span><span
 class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span
 class="n">div</span><span class="p">(</span><span class="n">den</span><span
 class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span
 class="nb">new</span><span class="p">(</span><span class="n">num</span><span
 class="p">,</span> <span class="n">den</span><span class="p">)</span>
    <span
 class="k">end</span>
<span class="k">end</span>
<span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span
 class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span
 class="n">n</span><span class="p">::</span><span class="n">T</span><span
 class="p">,</span> <span class="n">d</span><span class="p">::</span><span
 class="n">T</span><span class="p">)</span> <span class="o">=</span> <span
 class="n">Rational</span><span class="p">{</span><span class="n">T</span><span
 class="p">}(</span><span class="n">n</span><span class="p">,</span><span
 class="n">d</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span
 class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span
 class="n">d</span><span class="p">::</span><span class="n">Integer</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span
 class="p">(</span><span class="nb">promote</span><span class="p">(</span><span
 class="n">n</span><span class="p">,</span><span class="n">d</span><span
 class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span
 class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span
 class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span
 class="n">n</span><span class="p">,</span><span class="n">one</span><span
 class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="o">//</span><span class="p">(</span><span class="n">n</span><span
 class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span
 class="n">d</span><span class="p">::</span><span class="n">Integer</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span
 class="p">(</span><span class="n">n</span><span class="p">,</span><span
 class="n">d</span><span class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Rational</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="n">Integer</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">x</span><span
 class="o">.</span><span class="n">num</span> <span class="o">//</span> <span
 class="p">(</span><span class="n">x</span><span class="o">.</span><span
 class="n">den</span><span class="o">*</span><span class="n">y</span><span
 class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="n">Rational</span><span
 class="p">)</span> <span class="o">=</span> <span class="p">(</span><span
 class="n">x</span><span class="o">*</span><span class="n">y</span><span
 class="o">.</span><span class="n">den</span><span class="p">)</span> <span
 class="o">//</span> <span class="n">y</span><span class="o">.</span><span
 class="n">num</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Complex</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="n">Real</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">complex</span><span
 class="p">(</span><span class="n">real</span><span class="p">(</span><span
 class="n">x</span><span class="p">)</span><span class="o">//</span><span
 class="n">y</span><span class="p">,</span> <span class="n">imag</span><span
 class="p">(</span><span class="n">x</span><span class="p">)</span><span
 class="o">//</span><span class="n">y</span><span class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Real</span><span class="p">,</span> <span
 class="n">y</span><span class="p">::</span><span class="n">Complex</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">x</span><span
 class="o">*</span><span class="n">y</span><span class="o">'//</span><span
 class="n">real</span><span class="p">(</span><span class="n">y</span><span
 class="o">*</span><span class="n">y</span><span class="o">'</span><span
 class="p">)</span>

<span class="k">function</span><span class="nf"> </span><span class="o">//</span><span
 class="p">(</span><span class="n">x</span><span class="p">::</span><span
 class="n">Complex</span><span class="p">,</span> <span class="n">y</span><span
 class="p">::</span><span class="n">Complex</span><span class="p">)</span>
    <span
 class="n">xy</span> <span class="o">=</span> <span class="n">x</span><span
 class="o">*</span><span class="n">y</span><span class="o">'</span>
    <span
 class="n">yy</span> <span class="o">=</span> <span class="n">real</span><span
 class="p">(</span><span class="n">y</span><span class="o">*</span><span
 class="n">y</span><span class="o">'</span><span class="p">)</span>
    <span
 class="n">complex</span><span class="p">(</span><span class="n">real</span><span
 class="p">(</span><span class="n">xy</span><span class="p">)</span><span
 class="o">//</span><span class="n">yy</span><span class="p">,</span> <span
 class="n">imag</span><span class="p">(</span><span class="n">xy</span><span
 class="p">)</span><span class="o">//</span><span class="n">yy</span><span
 class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>The first line — <code class="docutils literal"><span class="pre">immutable</span>
<span class="pre">Rational{T&lt;:Int}</span> <span class="pre">&lt;:</span>
<span class="pre">Real</span></code> — declares that
<code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
takes one type parameter of an integer type, and is itself
a real type. The field declarations <code class="docutils literal"><span
 class="pre">num::T</span></code> and <code class="docutils literal"><span
 class="pre">den::T</span></code> indicate
that the data held in a <code class="docutils literal"><span
 class="pre">Rational{T}</span></code> object are a pair of integers of
type <code class="docutils literal"><span class="pre">T</span></code>,
one representing the rational value’s numerator and the
other representing its denominator.</p>
<p>Now things get interesting. <code
 class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
has a single inner constructor
method which checks that both of <code class="docutils literal"><span
 class="pre">num</span></code> and <code class="docutils literal"><span
 class="pre">den</span></code> aren’t zero and
ensures that every rational is constructed in “lowest terms” with a
non-negative denominator. This is accomplished by dividing the given
numerator and denominator values by their greatest common divisor,
computed using the <code class="docutils literal"><span class="pre">gcd</span></code>
function. Since <code class="docutils literal"><span class="pre">gcd</span></code>
returns the greatest
common divisor of its arguments with sign matching the first argument
(<code class="docutils literal"><span class="pre">den</span></code>
here), after this division the new value of <code
 class="docutils literal"><span class="pre">den</span></code> is
guaranteed to be non-negative. Because this is the only inner
constructor for <code class="xref jl jl-class docutils literal"><span
 class="pre">Rational</span></code>, we can be certain that <code
 class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
objects are always constructed in this normalized form.</p>
<p><code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
also provides several outer constructor methods for
convenience. The first is the “standard” general constructor that
infers
the type parameter <code class="docutils literal"><span class="pre">T</span></code>
from the type of the numerator and denominator
when they have the same type. The second applies when the given
numerator and denominator values have different types: it promotes them
to a common type and then delegates construction to the outer
constructor for arguments of matching type. The third outer constructor
turns integer values into rationals by supplying a value of <code
 class="docutils literal"><span class="pre">1</span></code> as the
denominator.</p>
<p>Following the outer constructor definitions, we have a number of
methods
for the <a class="reference internal"
 href="../stdlib/math.html#Base.//" title="Base.//"><code
 class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a>
operator, which provides a syntax for writing rationals.
Before these definitions, <a class="reference internal"
 href="../stdlib/math.html#Base.//" title="Base.//"><code
 class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a>
is a completely undefined operator with
only syntax and no meaning. Afterwards, it behaves just as described in
<a class="reference internal"
 href="complex-and-rational-numbers.html#man-rational-numbers"><span>Rational
Numbers</span></a>
— its entire behavior is defined in these few lines. The first and most
basic definition just makes <code class="docutils literal"><span
 class="pre">a//b</span></code> construct a <code
 class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
by
applying the <code class="xref jl jl-class docutils literal"><span
 class="pre">Rational</span></code> constructor to <code
 class="docutils literal"><span class="pre">a</span></code> and <code
 class="docutils literal"><span class="pre">b</span></code> when they
are
integers. When one of the operands of <a class="reference internal"
 href="../stdlib/math.html#Base.//" title="Base.//"><code
 class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a>
is already a rational
number, we construct a new rational for the resulting ratio slightly
differently; this behavior is actually identical to division of a
rational with an integer. Finally, applying <a
 class="reference internal" href="../stdlib/math.html#Base.//"
 title="Base.//"><code class="xref jl jl-obj docutils literal"><span
 class="pre">//</span></code></a> to complex integral
values creates an instance of <code class="docutils literal"><span
 class="pre">Complex{Rational}</span></code> — a complex number
whose real and imaginary parts are rationals:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span
 class="mi">2</span><span class="nb">im</span><span class="p">)</span><span
 class="o">//</span><span class="p">(</span><span class="mi">1</span> <span
 class="o">-</span> <span class="mi">2</span><span class="nb">im</span><span
 class="p">)</span>
<span class="o">-</span><span class="mi">3</span><span class="o">//</span><span
 class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span
 class="o">//</span><span class="mi">5</span><span class="o">*</span><span
 class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Complex</span><span class="p">{</span><span class="n">Rational</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ans</span> <span
 class="o">&lt;:</span> <span class="n">Complex</span><span class="p">{</span><span
 class="n">Rational</span><span class="p">}</span>
<span class="n">false</span>
</pre>
</div>
</div>
<p>Thus, although the <a class="reference internal"
 href="../stdlib/math.html#Base.//" title="Base.//"><code
 class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a>
operator usually returns an instance of
<code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>,
if either of its arguments are complex integers, it will
return an instance of <code class="docutils literal"><span class="pre">Complex{Rational}</span></code>
instead. The interested
reader should consider perusing the rest of
<a class="reference external"
 href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>:
it is short, self-contained, and implements an entire basic Julia type.</p>
</div>
<div class="section" id="constructors-call-and-conversion">
<span id="id4"></span>
<h2><span id="result_box" class="short_text" lang="ja"><span>コンストラクタ</span><span>、</span><span
 class="">コール</span><span class="">、</span><span class="">および</span><span
 class="">変換</span></span><a class="headerlink"
 href="#constructors-call-and-conversion"
 title="Permalink to this headline"></a></h2>
<p>Technically, constructors <code class="docutils literal"><span
 class="pre">T(args...)</span></code> in Julia are implemented by
defining new methods <code class="docutils literal"><span class="pre">Base.call(::Type{T},</span>
<span class="pre">args...)</span></code> for the
<a class="reference internal" href="../stdlib/base.html#Base.call"
 title="Base.call"><code class="xref jl jl-func docutils literal"><span
 class="pre">call()</span></code></a> function. That is, Julia types
are not functions, but
they can be called as if they were functions (functors) via
call overloading, just like any other Julia object. This also means
that you can declare more flexible constructors, e.g. constructors for
abstract types, by instead explicitly defining <code
 class="docutils literal"><span class="pre">Base.call</span></code>
methods
using <code class="docutils literal"><span class="pre">function</span></code>
syntax.</p>
<p>However, in some cases you could consider adding methods to
<code class="docutils literal"><span class="pre">Base.convert</span></code>
<em>instead</em> of defining a constructor, because defining
a <a class="reference internal" href="../stdlib/base.html#Base.convert"
 title="Base.convert"><code class="xref jl jl-func docutils literal"><span
 class="pre">convert()</span></code></a> method <em>automatically</em>
defines a corresponding
constructor, while the reverse is not true. That is, defining
<code class="docutils literal"><span class="pre">Base.convert(::Type{T},</span>
<span class="pre">args...)</span> <span class="pre">=</span> <span
 class="pre">...</span></code> automatically defines a
constructor <code class="docutils literal"><span class="pre">T(args...)</span>
<span class="pre">=</span> <span class="pre">...</span></code>.</p>
<p><code class="docutils literal"><span class="pre">convert</span></code>
is used extensively throughout Julia whenever one type
needs to be converted to another (e.g. in assignment, <code
 class="docutils literal"><span class="pre">ccall</span></code>,
etcetera), and should generally only be defined (or successful) if the
conversion is lossless. For example, <code class="docutils literal"><span
 class="pre">convert(Int,</span> <span class="pre">3.0)</span></code>
produces
<code class="docutils literal"><span class="pre">3</span></code>, but <code
 class="docutils literal"><span class="pre">convert(Int,</span> <span
 class="pre">3.2)</span></code> throws an <code
 class="docutils literal"><span class="pre">InexactError</span></code>.
If you
want to define a constructor for a lossless conversion from one type
to another, you should probably define a <code class="docutils literal"><span
 class="pre">convert</span></code> method instead.</p>
<p>On the other hand, if your constructor does not represent a lossless
conversion, or doesn’t represent “conversion” at all, it is better
to leave it as a constructor rather than a <code
 class="docutils literal"><span class="pre">convert</span></code>
method. For
example, the <code class="docutils literal"><span class="pre">Array(Int)</span></code>
constructor creates a zero-dimensional
<code class="docutils literal"><span class="pre">Array</span></code> of
the type <code class="docutils literal"><span class="pre">Int</span></code>,
but is not really a “conversion” from
<code class="docutils literal"><span class="pre">Int</span></code> to
an <code class="docutils literal"><span class="pre">Array</span></code>.</p>
</div>
<div class="section" id="outer-only-constructors">
<h2><span id="result_box" class="short_text" lang="ja"><span>外側</span><span>の
みの</span><span class="">コンストラクタ</span></span><a class="headerlink"
 href="#outer-only-constructors" title="Permalink to this headline"></a></h2>
<p>As we have seen, a typical parametric type has inner constructors
that are called when type parameters are known; e.g. they apply
to <code class="docutils literal"><span class="pre">Point{Int}</span></code>
but not to <code class="docutils literal"><span class="pre">Point</span></code>.
Optionally, outer constructors that determine type parameters
automatically can be added, for example constructing a
<code class="docutils literal"><span class="pre">Point{Int}</span></code>
from the call <code class="docutils literal"><span class="pre">Point(1,2)</span></code>.
Outer constructors call inner constructors to do the core
work of making an instance.
However, in some cases one would rather not provide inner constructors,
so that specific type parameters cannot be requested manually.</p>
<p>For example, say we define a type that stores a vector along with
an accurate representation of its sum:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> SummedArray</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Number</span><span class="p">,</span><span class="n">S</span><span
 class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span>
    <span
 class="n">data</span><span class="p">::</span><span class="n">Vector</span><span
 class="p">{</span><span class="n">T</span><span class="p">}</span>
    <span
 class="n">sum</span><span class="p">::</span><span class="n">S</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>The problem is that we want <code class="docutils literal"><span
 class="pre">S</span></code> to be a larger type than <code
 class="docutils literal"><span class="pre">T</span></code>, so
that we can sum many elements with less information loss.
For example, when <code class="docutils literal"><span class="pre">T</span></code>
is <code class="docutils literal"><span class="pre">Int32</span></code>,
we would like <code class="docutils literal"><span class="pre">S</span></code>
to be <code class="docutils literal"><span class="pre">Int64</span></code>.
Therefore we want to avoid an interface that allows the user to
construct
instances of the type <code class="docutils literal"><span class="pre">SummedArray{Int32,Int32}</span></code>.
One way to do this is to provide only an outer constructor for <code
 class="docutils literal"><span class="pre">SummedArray</span></code>.
This can be done using explicit <code class="docutils literal"><span
 class="pre">call</span></code> overloading:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> SummedArray</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Number</span><span class="p">,</span><span class="n">S</span><span
 class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span>
    <span
 class="n">data</span><span class="p">::</span><span class="n">Vector</span><span
 class="p">{</span><span class="n">T</span><span class="p">}</span>
    <span
 class="n">sum</span><span class="p">::</span><span class="n">S</span>

    <span
 class="k">function</span><span class="nf"> call</span><span class="p">{</span><span
 class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span
 class="p">{</span><span class="n">SummedArray</span><span class="p">},</span> <span
 class="n">a</span><span class="p">::</span><span class="n">Vector</span><span
 class="p">{</span><span class="n">T</span><span class="p">})</span>
        <span
 class="n">S</span> <span class="o">=</span> <span class="n">widen</span><span
 class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span
 class="nb">new</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">S</span><span class="p">}(</span><span
 class="n">a</span><span class="p">,</span> <span class="n">sum</span><span
 class="p">(</span><span class="n">S</span><span class="p">,</span> <span
 class="n">a</span><span class="p">))</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>This constructor will be invoked by the syntax <code
 class="docutils literal"><span class="pre">SummedArray(a)</span></code>.
The syntax <code class="docutils literal"><span class="pre">new{T,S}</span></code>
allows specifying parameters for the type to be
constructed, i.e. this call will return a <code
 class="docutils literal"><span class="pre">SummedArray{T,S}</span></code>.</p>
</div>
</div>
</div>
<footer> </footer><a href="https://readthedocs.org"></a> </div>
</div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
<script type="text/javascript" src="../_static/jquery.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript"
 src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../_static/js/theme.js"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
</body>
</html>
