<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]--><!--[if gt IE 8]><!--><!--<![endif]-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Frequently Asked Questions — Julia Language 0.4.3 documentation</title>
  <link
 href="https://fonts.googleapis.com/css?family=Lato:400,700%7CRoboto+Slab:400,700%7CInconsolata:400,700"
 rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="top" title="Julia Language 0.4.3 documentation"
 href="../index.html">
  <link rel="next" title="Noteworthy Differences from other Languages"
 href="noteworthy-differences.html">
  <link rel="prev" title="Style Guide" href="style-guide.html">
  <script
 src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<div class="wy-nav-content">
<div class="rst-content">
<div role="main" class="document">
<div class="section" id="frequently-asked-questions">
<h1><span id="result_box" class="short_text" lang="ja"><span class="hps">よ
くある質問</span></span><a class="headerlink"
 href="#frequently-asked-questions" title="Permalink to this headline"></a></h1>
<div class="section" id="sessions-and-the-repl">
<h2><span id="result_box" class="short_text" lang="ja"><span>セッションと</span><span
 class="">REPL</span></span><a class="headerlink"
 href="#sessions-and-the-repl" title="Permalink to this headline"></a></h2>
<div class="section" id="how-do-i-delete-an-object-in-memory">
<h3><span id="result_box" class="short_text" lang="ja"><span>どのように私は</span><span>メ
モリ</span><span>内のオブジェクト</span><span>を削除</span><span class="">しますか？</span></span><a
 class="headerlink" href="#how-do-i-delete-an-object-in-memory"
 title="Permalink to this headline"></a></h3>
<p>Julia does not have an analog of MATLAB’s <code
 class="docutils literal"><span class="pre">clear</span></code>
function; once a
name is defined in a Julia session (technically, in module <code
 class="docutils literal"><span class="pre">Main</span></code>),
it is always present.</p>
<p>If memory usage is your concern, you can always replace objects with
ones that consume less memory. For example, if <code
 class="docutils literal"><span class="pre">A</span></code> is a
gigabyte-sized array that you no longer need, you can free the memory
with <code class="docutils literal"><span class="pre">A</span> <span
 class="pre">=</span> <span class="pre">0</span></code>. The memory
will be released the next time the garbage
collector runs; you can force this to happen with <a
 class="reference internal" href="../stdlib/base.html#Base.gc"
 title="Base.gc"><code class="xref jl jl-func docutils literal"><span
 class="pre">gc()</span></code></a>.</p>
</div>
<div class="section"
 id="how-can-i-modify-the-declaration-of-a-type-immutable-in-my-session">
<h3><span id="result_box" class="short_text" lang="ja"><span>どのように私は私の</span><span>セッ
ションで</span><span>不変</span><span>型の宣言</span><span>を</span><span>/</span><span
 class="">変更することができます</span><span class="">？</span></span><a
 class="headerlink"
 href="#how-can-i-modify-the-declaration-of-a-type-immutable-in-my-session"
 title="Permalink to this headline"></a></h3>
<p>Perhaps you’ve defined a type and then realize you need to add a
new field. If you try this at the REPL, you get the error:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">ERROR</span><span class="p">:</span> <span
 class="n">invalid</span> <span class="n">redefinition</span> <span
 class="n">of</span> <span class="n">constant</span> <span class="n">MyType</span>
</pre>
</div>
</div>
<p>Types in module <code class="docutils literal"><span class="pre">Main</span></code>
cannot be redefined.</p>
<p>While this can be inconvenient when you are developing new code,
there’s an excellent workaround. Modules can be replaced by
redefining them, and so if you wrap all your new code inside a module
you can redefine types and constants. You can’t import the type names
into <code class="docutils literal"><span class="pre">Main</span></code>
and then expect to be able to redefine them there, but
you can use the module name to resolve the scope. In other words,
while developing you might use a workflow something like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">include</span><span class="p">(</span><span
 class="s">"mynewcode.jl"</span><span class="p">)</span>              <span
 class="c"># this defines a module MyModule</span>
<span class="n">obj1</span> <span class="o">=</span> <span class="n">MyModule</span><span
 class="o">.</span><span class="n">ObjConstructor</span><span class="p">(</span><span
 class="n">a</span><span class="p">,</span> <span class="n">b</span><span
 class="p">)</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">MyModule</span><span
 class="o">.</span><span class="n">somefunction</span><span class="p">(</span><span
 class="n">obj1</span><span class="p">)</span>
<span class="c"># Got an error. Change something in "mynewcode.jl"</span>
<span class="n">include</span><span class="p">(</span><span class="s">"mynewcode.jl"</span><span
 class="p">)</span>              <span class="c"># reload the module</span>
<span class="n">obj1</span> <span class="o">=</span> <span class="n">MyModule</span><span
 class="o">.</span><span class="n">ObjConstructor</span><span class="p">(</span><span
 class="n">a</span><span class="p">,</span> <span class="n">b</span><span
 class="p">)</span> <span class="c"># old objects are no longer valid, must reconstruct</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">MyModule</span><span
 class="o">.</span><span class="n">somefunction</span><span class="p">(</span><span
 class="n">obj1</span><span class="p">)</span>   <span class="c"># this time it worked!</span>
<span class="n">obj3</span> <span class="o">=</span> <span class="n">MyModule</span><span
 class="o">.</span><span class="n">someotherfunction</span><span
 class="p">(</span><span class="n">obj2</span><span class="p">,</span> <span
 class="n">c</span><span class="p">)</span>
<span class="o">...</span>
</pre>
</div>
</div>
</div>
</div>
<div class="section" id="functions">
<h2><span id="result_box" class="short_text" lang="ja"><span class="">関数</span></span><a
 class="headerlink" href="#functions" title="Permalink to this headline"></a></h2>
<div class="section"
 id="i-passed-an-argument-x-to-a-function-modified-it-inside-that-function-but-on-the-outside-the-variable-x-is-still-unchanged-why">
<h3><span id="result_box" class="" lang="ja"><span>私は</span><span>、</span><span>関
数の</span><span>引数x</span><span>を</span><span>渡し</span><span>、その関数内で</span><span>そ
れを</span><span>修正</span><span>するが、</span><span>外側に</span><span>、</span><span>変
数x</span><span>は、まだ</span><span>変更されません</span><span>。</span> <span
 class="hps">なぜ？</span></span><a class="headerlink"
 href="#i-passed-an-argument-x-to-a-function-modified-it-inside-that-function-but-on-the-outside-the-variable-x-is-still-unchanged-why"
 title="Permalink to this headline"></a></h3>
<p>Suppose you call a function like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span
 class="nf"> change_value</span><span class="o">!</span><span class="p">(</span><span
 class="n">y</span><span class="p">)</span> <span class="c"># Create a new function</span>
           <span
 class="n">y</span> <span class="o">=</span> <span class="mi">17</span>
       <span
 class="k">end</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">change_value</span><span
 class="o">!</span><span class="p">(</span><span class="n">x</span><span
 class="p">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span
 class="c"># x is unchanged!</span>
<span class="mi">10</span>
</pre>
</div>
</div>
<p>In Julia, any function (including <code class="docutils literal"><span
 class="pre">change_value!()</span></code>) can’t change the binding of
a local variable. If <code class="docutils literal"><span class="pre">x</span></code>
(in the calling scope) is bound to a immutable object (like a real
number), you can’t modify the object; likewise, if x is bound in the
calling scope to a Dict, you can’t change it to be bound to an
ASCIIString.</p>
<p>But here is a thing you should pay attention to: suppose <code
 class="docutils literal"><span class="pre">x</span></code> is bound to
an Array (or any other mutable type). You cannot “unbind” <code
 class="docutils literal"><span class="pre">x</span></code> from this
Array. But, since an Array is a <em>mutable</em> type, you can change
its content. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">x</span> <span class="o">=</span> <span class="p">[</span><span
 class="mi">1</span><span class="p">,</span><span class="mi">2</span><span
 class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span
 class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="mi">1</span><span class="p">}:</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span
 class="nf"> change_array</span><span class="o">!</span><span class="p">(</span><span
 class="n">A</span><span class="p">)</span> <span class="c"># Create a new function</span>
           <span
 class="n">A</span><span class="p">[</span><span class="mi">1</span><span
 class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
       <span
 class="k">end</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">change_array</span><span
 class="o">!</span><span class="p">(</span><span class="n">x</span><span
 class="p">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span
 class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="mi">1</span><span class="p">}:</span>
<span class="mi">5</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre>
</div>
</div>
<p>Here we created a function <code class="docutils literal"><span
 class="pre">change_array!()</span></code>, that assigns <code
 class="docutils literal"><span class="pre">5</span></code> to the
first element of the Array. We passed <code class="docutils literal"><span
 class="pre">x</span></code> (which was previously bound to an Array)
to the function. Notice that, after the function call, <code
 class="docutils literal"><span class="pre">x</span></code> is still
bound to the same Array, but the content of that Array changed.</p>
</div>
<div class="section" id="can-i-use-using-or-import-inside-a-function">
<div id="gt-src-c" class="g-unit">
<div id="gt-src-p"> </div>
</div>
<div id="gt-res-content" class="almost_half_cell">
<div dir="ltr" style="">
<div id="tts_button"><object type="application/x-shockwave-flash"
 data="//ssl.gstatic.com/translate/sound_player2.swf" id="tts"
 height="18" width="18"></object></div>
<span id="result_box" class="short_text" lang="ja"
 style="font-weight: bold;"><span>私は、</span><span>関数内で</span><span>使用して、</span><span>ま
たはインポート</span><span class="">使用することはできますか？</span></span></div>
</div>
<h3><a class="headerlink"
 href="#can-i-use-using-or-import-inside-a-function"
 title="Permalink to this headline"></a></h3>
<p>No, you are not allowed to have a <code class="docutils literal"><span
 class="pre">using</span></code> or <code class="docutils literal"><span
 class="pre">import</span></code> statement inside
a function. If you want to import a module but only use its symbols
inside a specific function or set of functions, you have two options:</p>
<ol class="arabic">
  <li>
    <p class="first">Use <code class="docutils literal"><span
 class="pre">import</span></code>:</p>
    <div class="highlight-julia">
    <div class="highlight">
    <pre><span class="k">import</span> <span class="n">Foo</span>
<span class="k">function</span><span class="nf"> bar</span><span
 class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span
 class="o">...</span> <span class="n">refer</span> <span class="n">to</span> <span
 class="n">Foo</span> <span class="n">symbols</span> <span class="n">via</span> <span
 class="n">Foo</span><span class="o">.</span><span class="n">baz</span> <span
 class="o">...</span>
<span class="k">end</span>
    </pre>
    </div>
    </div>
    <p>This loads the module <code class="docutils literal"><span
 class="pre">Foo</span></code> and defines a variable <code
 class="docutils literal"><span class="pre">Foo</span></code> that
refers
to the module, but does not import any of the other symbols from the
module into the current namespace. You refer to the <code
 class="docutils literal"><span class="pre">Foo</span></code> symbols
by
their qualified names <code class="docutils literal"><span class="pre">Foo.bar</span></code>
etc.</p>
  </li>
  <li>
    <p class="first">Wrap your function in a module:</p>
    <div class="highlight-julia">
    <div class="highlight">
    <pre><span class="k">module</span> <span class="n">Bar</span>
<span class="k">export</span> <span class="n">bar</span>
<span class="k">using</span> <span class="n">Foo</span>
<span class="k">function</span><span class="nf"> bar</span><span
 class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span
 class="o">...</span> <span class="n">refer</span> <span class="n">to</span> <span
 class="n">Foo</span><span class="o">.</span><span class="n">baz</span> <span
 class="n">as</span> <span class="n">simply</span> <span class="n">baz</span> <span
 class="o">....</span>
<span class="k">end</span>
<span class="k">end</span>
<span class="k">using</span> <span class="n">Bar</span>
    </pre>
    </div>
    </div>
    <p>This imports all the symbols from <code class="docutils literal"><span
 class="pre">Foo</span></code>, but only inside the module <code
 class="docutils literal"><span class="pre">Bar</span></code>.</p>
  </li>
</ol>
</div>
<div class="section" id="what-does-the-operator-do">
<div id="gt-src-c" class="g-unit">
<div id="gt-src-p"> </div>
</div>
<div id="gt-res-content" class="almost_half_cell">
<div dir="ltr" style="">
<div id="tts_button"><object type="application/x-shockwave-flash"
 data="//ssl.gstatic.com/translate/sound_player2.swf" id="tts"
 height="18" width="18"></object></div>
<span id="result_box" class="short_text" lang="ja"
 style="font-weight: bold;"><span>...</span><span>演算子</span><span>は何</span><span
 class="">をするのでしょうか？</span></span></div>
</div>
<h3><a class="headerlink" href="#what-does-the-operator-do"
 title="Permalink to this headline"></a></h3>
</div>
<div class="section"
 id="the-two-uses-of-the-operator-slurping-and-splatting">
<h3><span id="result_box" class="short_text" lang="ja"><span>2</span><span>...</span><span
 class="">オペレータ</span><span class="">の使用</span><span class="">：</span><span
 class="">ズルズル</span><span class="">と</span><span class="">吐き</span></span><a
 class="headerlink"
 href="#the-two-uses-of-the-operator-slurping-and-splatting"
 title="Permalink to this headline"></a></h3>
<p>Many newcomers to Julia find the use of <code
 class="docutils literal"><span class="pre">...</span></code> operator
confusing. Part of
what makes the <code class="docutils literal"><span class="pre">...</span></code>
operator confusing is that it means two different things
depending on context.</p>
</div>
<div class="section"
 id="combines-many-arguments-into-one-argument-in-function-definitions">
<h3><code class="docutils literal"><span class="pre"><span
 style="font-family: sans-serif;">...は、関数定義内の1つの引数に多くの引数を組み合わせて</span></span></code><a
 class="headerlink"
 href="#combines-many-arguments-into-one-argument-in-function-definitions"
 title="Permalink to this headline"></a></h3>
<p>In the context of function definitions, the <code
 class="docutils literal"><span class="pre">...</span></code> operator
is used to combine
many different arguments into a single argument. This use of <code
 class="docutils literal"><span class="pre">...</span></code> for
combining many different arguments into a single argument is called
slurping:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">function</span><span class="nf"> printargs</span><span
 class="p">(</span><span class="n">args</span><span class="o">...</span><span
 class="p">)</span>
           <span class="p">@</span><span class="n">printf</span><span
 class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span
 class="s">"</span><span class="p">,</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">args</span><span class="p">))</span>
           <span
 class="k">for</span> <span class="p">(</span><span class="n">i</span><span
 class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span
 class="k">in</span> <span class="n">enumerate</span><span class="p">(</span><span
 class="n">args</span><span class="p">)</span>
               <span
 class="p">@</span><span class="n">printf</span><span class="p">(</span><span
 class="s">"Arg %d = %s</span><span class="se">\n</span><span class="s">"</span><span
 class="p">,</span> <span class="n">i</span><span class="p">,</span> <span
 class="n">arg</span><span class="p">)</span>
           <span
 class="k">end</span>
       <span class="k">end</span>
<span class="n">printargs</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">printargs</span><span
 class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
 class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span
 class="p">)</span>
<span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span
 class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span
 class="p">)</span>
<span class="n">Arg</span> <span class="mi">1</span> <span class="o">=</span> <span
 class="mi">1</span>
<span class="n">Arg</span> <span class="mi">2</span> <span class="o">=</span> <span
 class="mi">2</span>
<span class="n">Arg</span> <span class="mi">3</span> <span class="o">=</span> <span
 class="mi">3</span>
</pre>
</div>
</div>
<p>If Julia were a language that made more liberal use of ASCII
characters, the
slurping operator might have been written as <code
 class="docutils literal"><span class="pre">&lt;-...</span></code>
instead of <code class="docutils literal"><span class="pre">...</span></code>.</p>
</div>
<div class="section"
 id="splits-one-argument-into-many-different-arguments-in-function-calls">
<h3><span id="result_box" class="short_text" lang="ja"><span>...</span><span>関
数の呼び出し</span><span>には多くの</span><span>異なる引数</span><span>に</span><span>一つの
引数</span><span class="">を分割</span></span><a class="headerlink"
 href="#splits-one-argument-into-many-different-arguments-in-function-calls"
 title="Permalink to this headline"></a></h3>
<p>In contrast to the use of the <code class="docutils literal"><span
 class="pre">...</span></code> operator to denote slurping many
different arguments into one argument when defining a function, the <code
 class="docutils literal"><span class="pre">...</span></code>
operator is also used to cause a single function argument to be split
apart
into many different arguments when used in the context of a function
call. This
use of <code class="docutils literal"><span class="pre">...</span></code>
is called splatting:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">function</span><span class="nf"> threeargs</span><span
 class="p">(</span><span class="n">a</span><span class="p">,</span> <span
 class="n">b</span><span class="p">,</span> <span class="n">c</span><span
 class="p">)</span>
           <span class="p">@</span><span class="n">printf</span><span
 class="p">(</span><span class="s">"a = %s::%s</span><span class="se">\n</span><span
 class="s">"</span><span class="p">,</span> <span class="n">a</span><span
 class="p">,</span> <span class="nb">typeof</span><span class="p">(</span><span
 class="n">a</span><span class="p">))</span>
           <span class="p">@</span><span
 class="n">printf</span><span class="p">(</span><span class="s">"b = %s::%s</span><span
 class="se">\n</span><span class="s">"</span><span class="p">,</span> <span
 class="n">b</span><span class="p">,</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">))</span>
           <span
 class="p">@</span><span class="n">printf</span><span class="p">(</span><span
 class="s">"c = %s::%s</span><span class="se">\n</span><span class="s">"</span><span
 class="p">,</span> <span class="n">c</span><span class="p">,</span> <span
 class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span
 class="p">))</span>
       <span class="k">end</span>
<span class="n">threeargs</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span
 class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">vec</span> <span
 class="o">=</span> <span class="p">[</span><span class="mi">1</span><span
 class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span
 class="mi">3</span><span class="p">]</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span
 class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span
 class="mi">1</span>
 <span class="mi">2</span>
 <span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">threeargs</span><span
 class="p">(</span><span class="n">vec</span><span class="o">...</span><span
 class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span
 class="p">::</span><span class="kt">Int64</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span
 class="p">::</span><span class="kt">Int64</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span
 class="p">::</span><span class="kt">Int64</span>
</pre>
</div>
</div>
<p>If Julia were a language that made more liberal use of ASCII
characters,
the splatting operator might have been written as <code
 class="docutils literal"><span class="pre">...-&gt;</span></code>
instead of <code class="docutils literal"><span class="pre">...</span></code>.</p>
</div>
</div>
<div class="section" id="types-type-declarations-and-constructors">
<h2><span id="result_box" class="short_text" lang="ja"><span>種類</span><span>、</span><span
 class="">型宣言</span><span>、</span><span class="">およびコンストラクタ</span></span><a
 class="headerlink" href="#types-type-declarations-and-constructors"
 title="Permalink to this headline"></a></h2>
<div class="section" id="what-does-type-stable-mean">
<span id="man-type-stable"></span>
<h3><span id="result_box" class="short_text" lang="ja"><span>「</span><span>タ
イプ</span><span>・</span><span>安定</span><span>」とは何</span><span class="">を意
味するのでしょうか？</span></span><a class="headerlink"
 href="#what-does-type-stable-mean" title="Permalink to this headline"></a></h3>
<p>It means that the type of the output is predictable from the types
of the inputs. In particular, it means that the type of the output
cannot vary depending on the <em>values</em> of the inputs. The
following
code is <em>not</em> type-stable:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">function</span><span class="nf"> unstable</span><span
 class="p">(</span><span class="n">flag</span><span class="p">::</span><span
 class="kt">Bool</span><span class="p">)</span>
    <span class="k">if</span> <span
 class="n">flag</span>
        <span class="k">return</span> <span
 class="mi">1</span>
    <span class="k">else</span>
        <span
 class="k">return</span> <span class="mf">1.0</span>
    <span
 class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>It returns either an <code class="docutils literal"><span
 class="pre">Int</span></code> or a <code class="docutils literal"><span
 class="pre">Float64</span></code> depending on the value of its
argument. Since Julia can’t predict the return type of this function at
compile-time, any computation that uses it will have to guard against
both
types possibly occurring, making generation of fast machine code
difficult.</p>
</div>
<div class="section"
 id="why-does-julia-give-a-domainerror-for-certain-seemingly-sensible-operations">
<span id="man-domain-error"></span>
<h3><span id="result_box" class="short_text" lang="ja"><span>なぜ</span>Julia<span>は、
特定の</span><span>一見</span><span>賢明な</span><span>操作のための</span><span
 class="">ドメインエラー</span><span>を与える</span><span>のでしょうか？</span></span><a
 class="headerlink"
 href="#why-does-julia-give-a-domainerror-for-certain-seemingly-sensible-operations"
 title="Permalink to this headline"></a></h3>
<p>Certain operations make mathematical sense but result in errors:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span
 class="mf">2.0</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span>
 <span
 class="k">in</span> <span class="n">sqrt</span> <span class="n">at</span> <span
 class="n">math</span><span class="o">.</span><span class="n">jl</span><span
 class="p">:</span><span class="mi">128</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span
 class="o">^-</span><span class="mi">5</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span>
 <span
 class="k">in</span> <span class="n">power_by_squaring</span> <span
 class="n">at</span> <span class="n">intfuncs</span><span class="o">.</span><span
 class="n">jl</span><span class="p">:</span><span class="mi">70</span>
 <span
 class="k">in</span> <span class="o">^</span> <span class="n">at</span> <span
 class="n">intfuncs</span><span class="o">.</span><span class="n">jl</span><span
 class="p">:</span><span class="mi">84</span>
</pre>
</div>
</div>
<p>This behavior is an inconvenient consequence of the requirement for
type-stability. In the case of <a class="reference internal"
 href="../stdlib/math.html#Base.sqrt" title="Base.sqrt"><code
 class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></code></a>,
most users want
<code class="docutils literal"><span class="pre">sqrt(2.0)</span></code>
to give a real number, and would be unhappy if it
produced the complex number <code class="docutils literal"><span
 class="pre">1.4142135623730951</span> <span class="pre">+</span> <span
 class="pre">0.0im</span></code>. One could
write the <a class="reference internal"
 href="../stdlib/math.html#Base.sqrt" title="Base.sqrt"><code
 class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></code></a>
function to switch to a complex-valued output only
when passed a negative number (which is what <a
 class="reference internal" href="../stdlib/math.html#Base.sqrt"
 title="Base.sqrt"><code class="xref jl jl-func docutils literal"><span
 class="pre">sqrt()</span></code></a> does in some
other languages), but then the result would not be <a
 class="reference external" href="#man-type-stable">type-stable</a> and
the <a class="reference internal" href="../stdlib/math.html#Base.sqrt"
 title="Base.sqrt"><code class="xref jl jl-func docutils literal"><span
 class="pre">sqrt()</span></code></a> function would have poor
performance.</p>
<p>In these and other cases, you can get the result you want by
choosing
an <em>input type</em> that conveys your willingness to accept an <em>output
type</em> in
which the result can be represented:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span
 class="mf">2.0</span><span class="o">+</span><span class="mi">0</span><span
 class="nb">im</span><span class="p">)</span>
<span class="mf">0.0</span> <span class="o">+</span> <span class="mf">1.4142135623730951</span><span
 class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">2.0</span><span
 class="o">^-</span><span class="mi">5</span>
<span class="mf">0.03125</span>
</pre>
</div>
</div>
</div>
<div class="section"
 id="why-does-julia-use-native-machine-integer-arithmetic">
<h3><span id="result_box" class="short_text" lang="ja"><span>なぜ</span><span>Julia</span><span>は、</span><span>ネ
イティブマシン</span><span>整数演算</span><span class="">を使用していますか？</span></span><a
 class="headerlink"
 href="#why-does-julia-use-native-machine-integer-arithmetic"
 title="Permalink to this headline"></a></h3>
<p>Julia uses machine arithmetic for integer computations. This means
that the range of <code class="docutils literal"><span class="pre">Int</span></code>
values is bounded and wraps around at either end so that adding,
subtracting and multiplying integers can overflow or underflow, leading
to some results that can be unsettling at first:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="nb">typemax</span><span class="p">(</span><span class="kt">Int</span><span
 class="p">)</span>
<span class="mi">9223372036854775807</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ans</span><span
 class="o">+</span><span class="mi">1</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">-</span><span
 class="n">ans</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span
 class="o">*</span><span class="n">ans</span>
<span class="mi">0</span>
</pre>
</div>
</div>
<p>Clearly, this is far from the way mathematical integers behave, and
you might
think it less than ideal for a high-level programming language to
expose this
to the user. For numerical work where efficiency and transparency are
at a
premium, however, the alternatives are worse.</p>
<p>One alternative to consider would be to check each integer operation
for
overflow and promote results to bigger integer types such as <code
 class="docutils literal"><span class="pre">Int128</span></code> or
<a class="reference internal" href="../stdlib/numbers.html#Base.BigInt"
 title="Base.BigInt"><code class="xref jl jl-class docutils literal"><span
 class="pre">BigInt</span></code></a> in the case of overflow.
Unfortunately, this introduces major
overhead on every integer operation (think incrementing a loop counter)
– it
requires emitting code to perform run-time overflow checks after
arithmetic
instructions and branches to handle potential overflows. Worse still,
this
would cause every computation involving integers to be type-unstable.
As we
mentioned above, <a class="reference external" href="#man-type-stable">type-stability
is crucial</a> for effective
generation of efficient code. If you can’t count on the results of
integer
operations being integers, it’s impossible to generate fast, simple
code the
way C and Fortran compilers do.</p>
<p>A variation on this approach, which avoids the appearance of type
instability is to merge the <code class="docutils literal"><span
 class="pre">Int</span></code> and <a class="reference internal"
 href="../stdlib/numbers.html#Base.BigInt" title="Base.BigInt"><code
 class="xref jl jl-class docutils literal"><span class="pre">BigInt</span></code></a>
types into a single hybrid integer type, that internally changes
representation when a result no longer fits into the size of a machine
integer. While this superficially avoids type-instability at the level
of Julia code, it just sweeps the problem under the rug by foisting all
of the same difficulties onto the C code implementing this hybrid
integer type. This approach <em>can</em> be made to work and can even
be made quite fast in many cases, but has several drawbacks. One
problem is that the in-memory representation of integers and arrays of
integers no longer match the natural representation used by C, Fortran
and other languages with native machine integers. Thus, to interoperate
with those languages, we would ultimately need to introduce native
integer types anyway. Any unbounded representation of integers cannot
have a fixed number of bits, and thus cannot be stored inline in an
array with fixed-size slots – large integer values will always require
separate heap-allocated storage. And of course, no matter how clever a
hybrid integer implementation one uses, there are always performance
traps – situations where performance degrades unexpectedly. Complex
representation, lack of interoperability with C and Fortran, the
inability to represent integer arrays without additional heap storage,
and unpredictable performance characteristics make even the cleverest
hybrid integer implementations a poor choice for high-performance
numerical work.</p>
<p>An alternative to using hybrid integers or promoting to BigInts is
to use
saturating integer arithmetic, where adding to the largest integer
value
leaves it unchanged and likewise for subtracting from the smallest
integer
value. This is precisely what Matlab™ does:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="o">&gt;&gt;</span> <span class="n">int64</span><span
 class="p">(</span><span class="mi">9223372036854775807</span><span
 class="p">)</span>

<span class="n">ans</span> <span class="o">=</span>

  <span
 class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span
 class="p">(</span><span class="mi">9223372036854775807</span><span
 class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">ans</span> <span class="o">=</span>

  <span
 class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span
 class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span
 class="p">)</span>

<span class="n">ans</span> <span class="o">=</span>

 <span class="o">-</span><span
 class="mi">9223372036854775808</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span
 class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span
 class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">ans</span> <span class="o">=</span>

 <span class="o">-</span><span
 class="mi">9223372036854775808</span>
</pre>
</div>
</div>
<p>At first blush, this seems reasonable enough since
9223372036854775807 is much closer to 9223372036854775808 than
-9223372036854775808 is and integers are still represented with a fixed
size in a natural way that is compatible with C and Fortran. Saturated
integer arithmetic, however, is deeply problematic. The first and most
obvious issue is that this is not the way machine integer arithmetic
works, so implementing saturated operations requires emitting
instructions after each machine integer operation to check for
underflow or overflow and replace the result with <a
 class="reference internal" href="../stdlib/base.html#Base.typemin"
 title="Base.typemin"><code class="xref jl jl-func docutils literal"><span
 class="pre">typemin(Int)</span></code></a> or <a
 class="reference internal" href="../stdlib/base.html#Base.typemax"
 title="Base.typemax"><code class="xref jl jl-func docutils literal"><span
 class="pre">typemax(Int)</span></code></a> as appropriate. This alone
expands each integer operation from a single, fast instruction into
half a dozen instructions, probably including branches. Ouch. But it
gets worse – saturating integer arithmetic isn’t associative. Consider
this Matlab computation:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="o">&gt;&gt;</span> <span class="n">n</span> <span
 class="o">=</span> <span class="n">int64</span><span class="p">(</span><span
 class="mi">2</span><span class="p">)</span><span class="o">^</span><span
 class="mi">62</span>
<span class="mi">4611686018427387904</span>

<span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">+</span> <span
 class="p">(</span><span class="n">n</span> <span class="o">-</span> <span
 class="mi">1</span><span class="p">)</span>
<span class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span
 class="o">+</span> <span class="n">n</span><span class="p">)</span> <span
 class="o">-</span> <span class="mi">1</span>
<span class="mi">9223372036854775806</span>
</pre>
</div>
</div>
<p>This makes it hard to write many basic integer algorithms since a
lot of
common techniques depend on the fact that machine addition with
overflow <em>is</em>
associative. Consider finding the midpoint between integer values <code
 class="docutils literal"><span class="pre">lo</span></code> and
<code class="docutils literal"><span class="pre">hi</span></code> in
Julia using the expression <code class="docutils literal"><span
 class="pre">(lo</span> <span class="pre">+</span> <span class="pre">hi)</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">1</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span
 class="o">^</span><span class="mi">62</span>
<span class="mi">4611686018427387904</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span
 class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span
 class="n">n</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span
 class="mi">1</span>
<span class="mi">6917529027641081856</span>
</pre>
</div>
</div>
<p>See? No problem. That’s the correct midpoint between 2^62 and 2^63,
despite
the fact that <code class="docutils literal"><span class="pre">n</span>
<span class="pre">+</span> <span class="pre">2n</span></code> is
-4611686018427387904. Now try it in Matlab:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="o">&gt;&gt;</span> <span class="p">(</span><span
 class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span
 class="o">*</span><span class="n">n</span><span class="p">)</span><span
 class="o">/</span><span class="mi">2</span>

<span class="n">ans</span> <span class="o">=</span>

  <span
 class="mi">4611686018427387904</span>
</pre>
</div>
</div>
<p>Oops. Adding a <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>
operator to Matlab wouldn’t help, because saturation
that occurs when adding <code class="docutils literal"><span
 class="pre">n</span></code> and <code class="docutils literal"><span
 class="pre">2n</span></code> has already destroyed the information
necessary to compute the correct midpoint.</p>
<p>Not only is lack of associativity unfortunate for programmers who
cannot rely
it for techniques like this, but it also defeats almost anything
compilers
might want to do to optimize integer arithmetic. For example, since
Julia
integers use normal machine integer arithmetic, LLVM is free to
aggressively
optimize simple little functions like <code class="docutils literal"><span
 class="pre">f(k)</span> <span class="pre">=</span> <span class="pre">5k-1</span></code>.
The machine code for
this function is just this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">code_native</span><span class="p">(</span><span class="n">f</span><span
 class="p">,(</span><span class="kt">Int</span><span class="p">,))</span>
    <span
 class="o">.</span><span class="n">section</span>    <span class="n">__TEXT</span><span
 class="p">,</span><span class="n">__text</span><span class="p">,</span><span
 class="n">regular</span><span class="p">,</span><span class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">1</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span
 class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span
 class="n">RSP</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">1</span>
    <span class="n">lea</span> <span class="n">RAX</span><span
 class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span
 class="p">[</span><span class="n">RDI</span> <span class="o">+</span> <span
 class="mi">4</span><span class="o">*</span><span class="n">RDI</span> <span
 class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span
 class="n">pop</span> <span class="n">RBP</span>
    <span class="n">ret</span>
</pre>
</div>
</div>
<p>The actual body of the function is a single <code
 class="docutils literal"><span class="pre">lea</span></code>
instruction, which
computes the integer multiply and add at once. This is even more
beneficial
when <code class="docutils literal"><span class="pre">f</span></code>
gets inlined into another function:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">function</span><span class="nf"> g</span><span class="p">(</span><span
 class="n">k</span><span class="p">,</span><span class="n">n</span><span
 class="p">)</span>
         <span class="k">for</span> <span class="n">i</span> <span
 class="o">=</span> <span class="mi">1</span><span class="p">:</span><span
 class="n">n</span>
           <span class="n">k</span> <span class="o">=</span> <span
 class="n">f</span><span class="p">(</span><span class="n">k</span><span
 class="p">)</span>
         <span class="k">end</span>
         <span
 class="k">return</span> <span class="n">k</span>
       <span
 class="k">end</span>
<span class="n">g</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">2</span> <span
 class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_native</span><span
 class="p">(</span><span class="n">g</span><span class="p">,(</span><span
 class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span
 class="p">))</span>
    <span class="o">.</span><span class="n">section</span>    <span
 class="n">__TEXT</span><span class="p">,</span><span class="n">__text</span><span
 class="p">,</span><span class="n">regular</span><span class="p">,</span><span
 class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">3</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span
 class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span
 class="n">RSP</span>
    <span class="n">test</span>    <span
 class="n">RSI</span><span class="p">,</span> <span class="n">RSI</span>
    <span
 class="n">jle</span> <span class="mi">22</span>
    <span class="n">mov</span> <span
 class="n">EAX</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">3</span>
    <span class="n">lea</span> <span class="n">RDI</span><span
 class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span
 class="p">[</span><span class="n">RDI</span> <span class="o">+</span> <span
 class="mi">4</span><span class="o">*</span><span class="n">RDI</span> <span
 class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span
 class="n">inc</span> <span class="n">RAX</span>
    <span class="n">cmp</span> <span
 class="n">RAX</span><span class="p">,</span> <span class="n">RSI</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">2</span>
    <span class="n">jle</span> <span class="o">-</span><span
 class="mi">17</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">5</span>
    <span class="n">mov</span> <span class="n">RAX</span><span
 class="p">,</span> <span class="n">RDI</span>
    <span class="n">pop</span> <span
 class="n">RBP</span>
    <span class="n">ret</span>
</pre>
</div>
</div>
<p>Since the call to <code class="docutils literal"><span class="pre">f</span></code>
gets inlined, the loop body ends up being just a
single <code class="docutils literal"><span class="pre">lea</span></code>
instruction. Next, consider what happens if we make the number
of loop iterations fixed:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">function</span><span class="nf"> g</span><span class="p">(</span><span
 class="n">k</span><span class="p">)</span>
         <span class="k">for</span> <span
 class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span
 class="p">:</span><span class="mi">10</span>
           <span
 class="n">k</span> <span class="o">=</span> <span class="n">f</span><span
 class="p">(</span><span class="n">k</span><span class="p">)</span>
         <span
 class="k">end</span>
         <span class="k">return</span> <span
 class="n">k</span>
       <span class="k">end</span>
<span class="n">g</span> <span class="p">(</span><span class="n">generic</span> <span
 class="k">function</span><span class="nf"> with</span> <span class="mi">2</span> <span
 class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_native</span><span
 class="p">(</span><span class="n">g</span><span class="p">,(</span><span
 class="kt">Int</span><span class="p">,))</span>
    <span class="o">.</span><span
 class="n">section</span>    <span class="n">__TEXT</span><span
 class="p">,</span><span class="n">__text</span><span class="p">,</span><span
 class="n">regular</span><span class="p">,</span><span class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">3</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span
 class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span
 class="n">RSP</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">3</span>
    <span class="n">imul</span>    <span class="n">RAX</span><span
 class="p">,</span> <span class="n">RDI</span><span class="p">,</span> <span
 class="mi">9765625</span>
    <span class="n">add</span> <span
 class="n">RAX</span><span class="p">,</span> <span class="o">-</span><span
 class="mi">2441406</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span
 class="mi">5</span>
    <span class="n">pop</span> <span class="n">RBP</span>
    <span
 class="n">ret</span>
</pre>
</div>
</div>
<p>Because the compiler knows that integer addition and multiplication
are
associative and that multiplication distributes over addition – neither
of
which is true of saturating arithmetic – it can optimize the entire
loop down
to just a multiply and an add. Saturated arithmetic completely defeats
this
kind of optimization since associativity and distributivity can fail at
each
loop iteration, causing different outcomes depending on which iteration
the
failure occurs in. The compiler can unroll the loop, but it cannot
algebraically reduce multiple operations into fewer equivalent
operations.</p>
<p>The most reasonable alternative to having integer arithmetic
silently overflow
is to do checked arithmetic everywhere, raising errors when adds,
subtracts,
and multiplies overflow, producing values that are not value-correct.
In this
<a class="reference external" href="http://danluu.com/integer-overflow">blog
post</a>, Dan Luu analyzes this and
finds that rather than the trivial cost that this approach should in
theory
have, it ends up having a substantial cost due to compilers (LLVM and
GCC)
not gracefully optimizing around the added overflow checks. If this
improves
in the future, we could consider defaulting to checked integer
arithmetic in
Julia, but for now, we have to live with the possibility of overflow.</p>
</div>
<div class="section"
 id="how-do-abstract-or-ambiguous-fields-in-types-interact-with-the-compiler">
<span id="man-abstract-fields"></span>
<h3><span id="result_box" class="short_text" lang="ja"><span>どのよう</span><span>な
タイプ</span><span>で</span><span>「</span><span>抽象的</span><span>」</span><span>ま
たは</span><span>あいまいな</span><span class="">フィールドは、</span><span class="">コ
ンパイラ</span><span>と相互作用し</span><span>ていますか？</span></span><a
 class="headerlink"
 href="#how-do-abstract-or-ambiguous-fields-in-types-interact-with-the-compiler"
 title="Permalink to this headline"></a></h3>
<p>Types can be declared without specifying the types of their fields:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> MyAmbiguousType</span>
           <span
 class="n">a</span>
       <span class="k">end</span>
</pre>
</div>
</div>
<p>This allows <code class="docutils literal"><span class="pre">a</span></code>
to be of any type. This can often be useful, but it
does have a downside: for objects of type <code
 class="docutils literal"><span class="pre">MyAmbiguousType</span></code>,
the
compiler will not be able to generate high-performance code. The
reason is that the compiler uses the types of objects, not their
values, to determine how to build code. Unfortunately, very little can
be inferred about an object of type <code class="docutils literal"><span
 class="pre">MyAmbiguousType</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">b</span> <span class="o">=</span> <span class="n">MyAmbiguousType</span><span
 class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span><span class="p">(</span><span
 class="s">"Hello"</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span
 class="o">=</span> <span class="n">MyAmbiguousType</span><span
 class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span><span class="p">(</span><span
 class="mi">17</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span>
</pre>
</div>
</div>
<p><code class="docutils literal"><span class="pre">b</span></code> and
<code class="docutils literal"><span class="pre">c</span></code> have
the same type, yet their underlying
representation of data in memory is very different. Even if you stored
just numeric values in field <code class="docutils literal"><span
 class="pre">a</span></code>, the fact that the memory
representation of a <code class="docutils literal"><span class="pre">UInt8</span></code>
differs from a <code class="docutils literal"><span class="pre">Float64</span></code>
also means
that the CPU needs to handle them using two different kinds of
instructions. Since the required information is not available in the
type, such decisions have to be made at run-time. This slows
performance.</p>
<p>You can do better by declaring the type of <code
 class="docutils literal"><span class="pre">a</span></code>. Here, we
are focused
on the case where <code class="docutils literal"><span class="pre">a</span></code>
might be any one of several types, in which
case the natural solution is to use parameters. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> MyType</span><span class="p">{</span><span
 class="n">T</span><span class="o">&lt;:</span><span class="n">AbstractFloat</span><span
 class="p">}</span>
         <span class="n">a</span><span class="p">::</span><span
 class="n">T</span>
       <span class="k">end</span>
</pre>
</div>
</div>
<p>This is a better choice than</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> MyStillAmbiguousType</span>
         <span
 class="n">a</span><span class="p">::</span><span class="n">AbstractFloat</span>
       <span
 class="k">end</span>
</pre>
</div>
</div>
<p>because the first version specifies the type of <code
 class="docutils literal"><span class="pre">a</span></code> from the
type of
the wrapper object. For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">m</span> <span class="o">=</span> <span class="n">MyType</span><span
 class="p">(</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}(</span><span class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">t</span> <span
 class="o">=</span> <span class="n">MyStillAmbiguousType</span><span
 class="p">(</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">MyStillAmbiguousType</span><span class="p">(</span><span
 class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">MyStillAmbiguousType</span>
</pre>
</div>
</div>
<p>The type of field <code class="docutils literal"><span class="pre">a</span></code>
can be readily determined from the type of
<code class="docutils literal"><span class="pre">m</span></code>, but
not from the type of <code class="docutils literal"><span class="pre">t</span></code>.
Indeed, in <code class="docutils literal"><span class="pre">t</span></code>
it’s possible
to change the type of field <code class="docutils literal"><span
 class="pre">a</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span
 class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">t</span><span
 class="o">.</span><span class="n">a</span> <span class="o">=</span> <span
 class="mf">4.5f0</span>
<span class="mf">4.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">t</span><span class="o">.</span><span
 class="n">a</span><span class="p">)</span>
<span class="kt">Float32</span>
</pre>
</div>
</div>
<p>In contrast, once <code class="docutils literal"><span class="pre">m</span></code>
is constructed, the type of <code class="docutils literal"><span
 class="pre">m.a</span></code> cannot
change:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">m</span><span class="o">.</span><span class="n">a</span> <span
 class="o">=</span> <span class="mf">4.5f0</span>
<span class="mf">4.5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">m</span><span class="o">.</span><span
 class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>
</pre>
</div>
</div>
<p>The fact that the type of <code class="docutils literal"><span
 class="pre">m.a</span></code> is known from <code
 class="docutils literal"><span class="pre">m</span></code>‘s
type—coupled
with the fact that its type cannot change mid-function—allows the
compiler to generate highly-optimized code for objects like <code
 class="docutils literal"><span class="pre">m</span></code> but
not for objects like <code class="docutils literal"><span class="pre">t</span></code>.</p>
<p>Of course, all of this is true only if we construct <code
 class="docutils literal"><span class="pre">m</span></code> with a
concrete type. We can break this by explicitly constructing it with
an abstract type:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">m</span> <span class="o">=</span> <span class="n">MyType</span><span
 class="p">{</span><span class="n">AbstractFloat</span><span class="p">}(</span><span
 class="mf">3.2</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="n">AbstractFloat</span><span
 class="p">}(</span><span class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">m</span><span class="o">.</span><span
 class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span
 class="o">.</span><span class="n">a</span> <span class="o">=</span> <span
 class="mf">4.5f0</span>
<span class="mf">4.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">m</span><span class="o">.</span><span
 class="n">a</span><span class="p">)</span>
<span class="kt">Float32</span>
</pre>
</div>
</div>
<p>For all practical purposes, such objects behave identically to those
of <code class="docutils literal"><span class="pre">MyStillAmbiguousType</span></code>.</p>
<p>It’s quite instructive to compare the sheer amount code generated
for
a simple function</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">func</span><span class="p">(</span><span class="n">m</span><span
 class="p">::</span><span class="n">MyType</span><span class="p">)</span> <span
 class="o">=</span> <span class="n">m</span><span class="o">.</span><span
 class="n">a</span><span class="o">+</span><span class="mi">1</span>
</pre>
</div>
</div>
<p>using</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">code_llvm</span><span class="p">(</span><span
 class="n">func</span><span class="p">,(</span><span class="n">MyType</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">},))</span>
<span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span
 class="p">,(</span><span class="n">MyType</span><span class="p">{</span><span
 class="n">AbstractFloat</span><span class="p">},))</span>
<span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span
 class="p">,(</span><span class="n">MyType</span><span class="p">,))</span>
</pre>
</div>
</div>
<p>For reasons of length the results are not shown here, but you may
wish
to try this yourself. Because the type is fully-specified in the first
case, the compiler doesn’t need to generate any code to resolve the
type at run-time. This results in shorter and faster code.</p>
</div>
<div class="section"
 id="how-should-i-declare-abstract-container-type-fields">
<span id="man-abstract-container-type"></span>
<h3><span id="result_box" class="short_text" lang="ja"><span>どのように私は</span><span>、
「</span><span>抽象</span><span>コンテナタイプ</span><span>」</span><span>フィールドは、</span><span>宣
言する</span><span class="">必要がありますか？</span></span><a class="headerlink"
 href="#how-should-i-declare-abstract-container-type-fields"
 title="Permalink to this headline"></a></h3>
<p>The same best practices that apply in the <a
 class="reference external" href="#man-abstract-fields">previous section</a>
also work for container types:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="k">type</span><span class="nc"> MySimpleContainer</span><span
 class="p">{</span><span class="n">A</span><span class="o">&lt;:</span><span
 class="n">AbstractVector</span><span class="p">}</span>
         <span
 class="n">a</span><span class="p">::</span><span class="n">A</span>
       <span
 class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span
 class="nc"> MyAmbiguousContainer</span><span class="p">{</span><span
 class="n">T</span><span class="p">}</span>
         <span class="n">a</span><span
 class="p">::</span><span class="n">AbstractVector</span><span class="p">{</span><span
 class="n">T</span><span class="p">}</span>
       <span class="k">end</span>
</pre>
</div>
</div>
<p>For example:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">c</span> <span class="o">=</span> <span class="n">MySimpleContainer</span><span
 class="p">(</span><span class="mi">1</span><span class="p">:</span><span
 class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MySimpleContainer</span><span class="p">{</span><span
 class="n">UnitRange</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span
 class="o">=</span> <span class="n">MySimpleContainer</span><span
 class="p">([</span><span class="mi">1</span><span class="p">:</span><span
 class="mi">3</span><span class="p">;]);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MySimpleContainer</span><span class="p">{</span><span
 class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span
 class="p">,</span><span class="mi">1</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span
 class="o">=</span> <span class="n">MyAmbiguousContainer</span><span
 class="p">(</span><span class="mi">1</span><span class="p">:</span><span
 class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousContainer</span><span class="p">{</span><span
 class="kt">Int64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span
 class="o">=</span> <span class="n">MyAmbiguousContainer</span><span
 class="p">([</span><span class="mi">1</span><span class="p">:</span><span
 class="mi">3</span><span class="p">;]);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousContainer</span><span class="p">{</span><span
 class="kt">Int64</span><span class="p">}</span>
</pre>
</div>
</div>
<p>For <code class="docutils literal"><span class="pre">MySimpleContainer</span></code>,
the object is fully-specified by its type
and parameters, so the compiler can generate optimized functions. In
most instances, this will probably suffice.</p>
<p>While the compiler can now do its job perfectly well, there are
cases
where <em>you</em> might wish that your code could do different things
depending on the <em>element type</em> of <code
 class="docutils literal"><span class="pre">a</span></code>. Usually
the best way to
achieve this is to wrap your specific operation (here, <code
 class="docutils literal"><span class="pre">foo</span></code>) in a
separate function:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">function</span><span class="nf"> sumfoo</span><span
 class="p">(</span><span class="n">c</span><span class="p">::</span><span
 class="n">MySimpleContainer</span><span class="p">)</span>
    <span
 class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span
 class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span
 class="n">c</span><span class="o">.</span><span class="n">a</span>
        <span
 class="n">s</span> <span class="o">+=</span> <span class="n">foo</span><span
 class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span
 class="k">end</span>
    <span class="n">s</span>
<span class="k">end</span>

<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span
 class="o">=</span> <span class="n">x</span>
<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span
 class="p">::</span><span class="n">AbstractFloat</span><span class="p">)</span> <span
 class="o">=</span> <span class="n">round</span><span class="p">(</span><span
 class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
<p>This keeps things simple, while allowing the compiler to generate
optimized code in all cases.</p>
<p>However, there are cases where you may need to declare different
versions of the outer function for different element types of
<code class="docutils literal"><span class="pre">a</span></code>. You
could do it like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">function</span><span class="nf"> myfun</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">AbstractFloat</span><span class="p">}(</span><span class="n">c</span><span
 class="p">::</span><span class="n">MySimpleContainer</span><span
 class="p">{</span><span class="n">Vector</span><span class="p">{</span><span
 class="n">T</span><span class="p">}})</span>
    <span class="o">...</span>
<span class="k">end</span>
<span class="k">function</span><span class="nf"> myfun</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Integer</span><span class="p">}(</span><span class="n">c</span><span
 class="p">::</span><span class="n">MySimpleContainer</span><span
 class="p">{</span><span class="n">Vector</span><span class="p">{</span><span
 class="n">T</span><span class="p">}})</span>
    <span class="o">...</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>This works fine for <code class="docutils literal"><span class="pre">Vector{T}</span></code>,
but we’d also have to write
explicit versions for <code class="docutils literal"><span class="pre">UnitRange{T}</span></code>
or other abstract types. To
prevent such tedium, you can use two parameters in the declaration of
<code class="docutils literal"><span class="pre">MyContainer</span></code>:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> MyContainer</span><span
 class="p">{</span><span class="n">T</span><span class="p">,</span> <span
 class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractVector</span><span
 class="p">}</span>
    <span class="n">a</span><span class="p">::</span><span
 class="n">A</span>
<span class="k">end</span>
<span class="n">MyContainer</span><span class="p">(</span><span
 class="n">v</span><span class="p">::</span><span class="n">AbstractVector</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">MyContainer</span><span
 class="p">{</span><span class="n">eltype</span><span class="p">(</span><span
 class="n">v</span><span class="p">),</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">v</span><span class="p">)}(</span><span
 class="n">v</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span
 class="o">=</span> <span class="n">MyContainer</span><span class="p">(</span><span
 class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span
 class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyContainer</span><span class="p">{</span><span
 class="kt">Float64</span><span class="p">,</span><span class="n">UnitRange</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>
</pre>
</div>
</div>
<p>Note the somewhat surprising fact that <code
 class="docutils literal"><span class="pre">T</span></code> doesn’t
appear in the
declaration of field <code class="docutils literal"><span class="pre">a</span></code>,
a point that we’ll return to in a moment.
With this approach, one can write functions such as:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">function</span><span class="nf"> myfunc</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Integer</span><span class="p">,</span> <span class="n">A</span><span
 class="o">&lt;:</span><span class="n">AbstractArray</span><span
 class="p">}(</span><span class="n">c</span><span class="p">::</span><span
 class="n">MyContainer</span><span class="p">{</span><span class="n">T</span><span
 class="p">,</span><span class="n">A</span><span class="p">})</span>
    <span
 class="k">return</span> <span class="n">c</span><span class="o">.</span><span
 class="n">a</span><span class="p">[</span><span class="mi">1</span><span
 class="p">]</span><span class="o">+</span><span class="mi">1</span>
<span class="k">end</span>
<span class="c"># Note: because we can only define MyContainer for</span>
<span class="c"># A&lt;:AbstractArray, and any unspecified parameters are arbitrary,</span>
<span class="c"># the previous could have been written more succinctly as</span>
<span class="c">#     function myfunc{T&lt;:Integer}(c::MyContainer{T})</span>

<span class="k">function</span><span class="nf"> myfunc</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">AbstractFloat</span><span class="p">}(</span><span class="n">c</span><span
 class="p">::</span><span class="n">MyContainer</span><span class="p">{</span><span
 class="n">T</span><span class="p">})</span>
    <span class="k">return</span> <span
 class="n">c</span><span class="o">.</span><span class="n">a</span><span
 class="p">[</span><span class="mi">1</span><span class="p">]</span><span
 class="o">+</span><span class="mi">2</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> myfunc</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Integer</span><span class="p">}(</span><span class="n">c</span><span
 class="p">::</span><span class="n">MyContainer</span><span class="p">{</span><span
 class="n">T</span><span class="p">,</span><span class="n">Vector</span><span
 class="p">{</span><span class="n">T</span><span class="p">}})</span>
    <span
 class="k">return</span> <span class="n">c</span><span class="o">.</span><span
 class="n">a</span><span class="p">[</span><span class="mi">1</span><span
 class="p">]</span><span class="o">+</span><span class="mi">3</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span
 class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span
 class="mi">1</span><span class="p">:</span><span class="mi">3</span><span
 class="p">))</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span
 class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span
 class="mf">1.0</span><span class="p">:</span><span class="mi">3</span><span
 class="p">))</span>
<span class="mf">3.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span
 class="p">(</span><span class="n">MyContainer</span><span class="p">([</span><span
 class="mi">1</span><span class="p">:</span><span class="mi">3</span><span
 class="p">]))</span>
<span class="mi">4</span>
</pre>
</div>
</div>
<p>As you can see, with this approach it’s possible to specialize on
both
the element type <code class="docutils literal"><span class="pre">T</span></code>
and the array type <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>However, there’s one remaining hole: we haven’t enforced that <code
 class="docutils literal"><span class="pre">A</span></code>
has element type <code class="docutils literal"><span class="pre">T</span></code>,
so it’s perfectly possible to construct an
object like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">julia</span><span class="o">&gt;</span> <span
 class="n">b</span> <span class="o">=</span> <span class="n">MyContainer</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">,</span> <span
 class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}}(</span><span class="mf">1.3</span><span class="p">:</span><span
 class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyContainer</span><span class="p">{</span><span
 class="kt">Int64</span><span class="p">,</span><span class="n">UnitRange</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>
</pre>
</div>
</div>
<p>To prevent this, we can add an inner constructor:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">type</span><span class="nc"> MyBetterContainer</span><span
 class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span
 class="n">Real</span><span class="p">,</span> <span class="n">A</span><span
 class="o">&lt;:</span><span class="n">AbstractVector</span><span
 class="p">}</span>
    <span class="n">a</span><span class="p">::</span><span
 class="n">A</span>

    <span class="n">MyBetterContainer</span><span
 class="p">(</span><span class="n">v</span><span class="p">::</span><span
 class="n">AbstractVector</span><span class="p">{</span><span class="n">T</span><span
 class="p">})</span> <span class="o">=</span> <span class="nb">new</span><span
 class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">MyBetterContainer</span><span class="p">(</span><span
 class="n">v</span><span class="p">::</span><span class="n">AbstractVector</span><span
 class="p">)</span> <span class="o">=</span> <span class="n">MyBetterContainer</span><span
 class="p">{</span><span class="n">eltype</span><span class="p">(</span><span
 class="n">v</span><span class="p">),</span><span class="nb">typeof</span><span
 class="p">(</span><span class="n">v</span><span class="p">)}(</span><span
 class="n">v</span><span class="p">)</span>


<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span
 class="o">=</span> <span class="n">MyBetterContainer</span><span
 class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span
 class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span
 class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyBetterContainer</span><span class="p">{</span><span
 class="kt">Float64</span><span class="p">,</span><span class="n">UnitRange</span><span
 class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span
 class="o">=</span> <span class="n">MyBetterContainer</span><span
 class="p">{</span><span class="kt">Int64</span><span class="p">,</span> <span
 class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span
 class="p">}}(</span><span class="mf">1.3</span><span class="p">:</span><span
 class="mi">5</span><span class="p">);</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">no</span> <span
 class="n">method</span> <span class="n">MyBetterContainer</span><span
 class="p">(</span><span class="n">UnitRange</span><span class="p">{</span><span
 class="kt">Float64</span><span class="p">},)</span>
</pre>
</div>
</div>
<p>The inner constructor requires that the element type of <code
 class="docutils literal"><span class="pre">A</span></code> be <code
 class="docutils literal"><span class="pre">T</span></code>.</p>
</div>
</div>
<div class="section" id="packages-and-modules">
<span id="faq-packages"></span>
<h2><span id="result_box" class="short_text" lang="ja"><span>パッケージ</span><span
 class="">とモジュール</span></span></h2>
<div class="section"
 id="what-is-the-difference-between-using-and-importall">
<h3><span id="result_box" class="short_text" lang="ja"><span class="">「</span><span
 class="">using</span><span>」と「</span><span class="">importall</span><span
 class="">」</span><span class="">の違いは何ですか？</span></span><a
 class="headerlink"
 href="#what-is-the-difference-between-using-and-importall"
 title="Permalink to this headline"></a></h3>
<p>There is only one difference, and on the surface (syntax-wise) it
may seem very minor.
The difference between <code class="docutils literal"><span class="pre">using</span></code>
and <code class="docutils literal"><span class="pre">importall</span></code>
is that with <code class="docutils literal"><span class="pre">using</span></code>
you need to say
<code class="docutils literal"><span class="pre">function</span> <span
 class="pre">Foo.bar(..</span></code> to extend module Foo’s function
bar with a new method, but with
<code class="docutils literal"><span class="pre">importall</span></code>
or <code class="docutils literal"><span class="pre">import</span> <span
 class="pre">Foo.bar</span></code>, you only need to say <code
 class="docutils literal"><span class="pre">function</span> <span
 class="pre">bar(...</span></code> and it
automatically extends module Foo’s function bar.</p>
<p>If you use <code class="docutils literal"><span class="pre">importall</span></code>,
then <code class="docutils literal"><span class="pre">function</span> <span
 class="pre">Foo.bar(...</span></code> and <code
 class="docutils literal"><span class="pre">function</span> <span
 class="pre">bar(...</span></code> become
equivalent. If you use <code class="docutils literal"><span class="pre">using</span></code>,
then they are different.</p>
<p>The reason this is important enough to have been given separate
syntax is that you don’t
want to accidentally extend a function that you didn’t know existed,
because that could
easily cause a bug. This is most likely to happen with a method that
takes a common type
like a string or integer, because both you and the other module could
define a method to
handle such a common type. If you use <code class="docutils literal"><span
 class="pre">importall</span></code>, then you’ll replace the other
module’s
implementation of <code class="docutils literal"><span class="pre">bar(s::AbstractString)</span></code>
with your new implementation, which could easily do
something completely different (and break all/many future usages of the
other functions
in module Foo that depend on calling bar).</p>
</div>
</div>
<div class="section" id="nothingness-and-missing-values">
<span id="man-nothing"></span>
<h2><span id="result_box" class="short_text" lang="ja"><span class="">虚無</span><span
 class="">と</span><span class="">欠損値</span></span><a class="headerlink"
 href="#nothingness-and-missing-values"
 title="Permalink to this headline"></a></h2>
<div class="section" id="how-does-null-or-nothingness-work-in-julia">
<h3><span id="result_box" class="short_text" lang="ja"><span>どのように</span><span>「</span><span>ヌ
ル</span><span>」</span><span>または</span>Julia<span>の「</span><span>虚無</span><span>」</span><span
 class="">動作しますか？</span></span><a class="headerlink"
 href="#how-does-null-or-nothingness-work-in-julia"
 title="Permalink to this headline"></a></h3>
<p>Unlike many languages (for example, C and Java), Julia does not have
a
“null” value. When a reference (variable, object field, or array
element)
is uninitialized, accessing it will immediately throw an error. This
situation can be detected using the <code class="docutils literal"><span
 class="pre">isdefined</span></code> function.</p>
<p>Some functions are used only for their side effects, and do not need
to
return a value. In these cases, the convention is to return the value
<code class="docutils literal"><span class="pre">nothing</span></code>,
which is just a singleton object of type <code class="docutils literal"><span
 class="pre">Void</span></code>. This
is an ordinary type with no fields; there is nothing special about it
except for this convention, and that the REPL does not print anything
for it. Some language constructs that would not otherwise have a value
also yield <code class="docutils literal"><span class="pre">nothing</span></code>,
for example <code class="docutils literal"><span class="pre">if</span>
<span class="pre">false;</span> <span class="pre">end</span></code>.</p>
<p>For situations where a value exists only sometimes (for example,
missing
statistical data), it is best to use the <code class="docutils literal"><span
 class="pre">Nullable{T}</span></code> type, which allows
specifying the type of a missing value.</p>
<p>The empty tuple (<code class="docutils literal"><span class="pre">()</span></code>)
is another form of nothingness. But, it should not
really be thought of as nothing but rather a tuple of zero values.</p>
<p>In code written for Julia prior to version 0.4 you may occasionally
see <code class="docutils literal"><span class="pre">None</span></code>,
which is quite different. It is the empty (or “bottom”) type, a type
with no values
and no subtypes (except itself). This is now written as <code
 class="docutils literal"><span class="pre">Union{}</span></code> (an
empty union
type). You will generally not need to use this type.</p>
</div>
</div>
<div class="section" id="memory">
<h2>メモリ<a class="headerlink" href="#memory"
 title="Permalink to this headline"></a></h2>
<div class="section"
 id="why-does-x-y-allocate-memory-when-x-and-y-are-arrays">
<h3><span id="result_box" class="short_text" lang="ja"><span>xとy</span><span>が
配列の</span><span>とき</span><span>なぜ</span><span>X</span><span>+</span><span>=</span>
<span class="hps">yは</span><span>メモリを割り当てる</span><span class="">のですか？</span></span><a
 class="headerlink"
 href="#why-does-x-y-allocate-memory-when-x-and-y-are-arrays"
 title="Permalink to this headline"></a></h3>
<p>In julia, <code class="docutils literal"><span class="pre">x</span>
<span class="pre">+=</span> <span class="pre">y</span></code> gets
replaced during parsing by <code class="docutils literal"><span
 class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span>
<span class="pre">+</span> <span class="pre">y</span></code>.
For arrays, this has the consequence that, rather than storing the
result in the same location in memory as <code class="docutils literal"><span
 class="pre">x</span></code>, it allocates a new
array to store the result.</p>
<p>While this behavior might surprise some, the choice is deliberate.
The
main reason is the presence of <code class="docutils literal"><span
 class="pre">immutable</span></code> objects within julia,
which cannot change their value once created. Indeed, a number is an
immutable object; the statements <code class="docutils literal"><span
 class="pre">x</span> <span class="pre">=</span> <span class="pre">5;</span>
<span class="pre">x</span> <span class="pre">+=</span> <span
 class="pre">1</span></code> do not modify the
meaning of <code class="docutils literal"><span class="pre">5</span></code>,
they modify the value bound to <code class="docutils literal"><span
 class="pre">x</span></code>. For an
immutable, the only way to change the value is to reassign it.</p>
<p>To amplify a bit further, consider the following function:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="k">function</span><span class="nf"> power_by_squaring</span><span
 class="p">(</span><span class="n">x</span><span class="p">,</span> <span
 class="n">n</span><span class="p">::</span><span class="kt">Int</span><span
 class="p">)</span>
    <span class="n">ispow2</span><span class="p">(</span><span
 class="n">n</span><span class="p">)</span> <span class="o">||</span> <span
 class="nb">error</span><span class="p">(</span><span class="s">"This implementation only works for powers of 2"</span><span
 class="p">)</span>
    <span class="k">while</span> <span class="n">n</span> <span
 class="o">&gt;=</span> <span class="mi">2</span>
        <span
 class="n">x</span> <span class="o">*=</span> <span class="n">x</span>
        <span
 class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span
 class="k">end</span>
    <span class="n">x</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>After a call like <code class="docutils literal"><span class="pre">x</span>
<span class="pre">=</span> <span class="pre">5;</span> <span
 class="pre">y</span> <span class="pre">=</span> <span class="pre">power_by_squaring(x,</span>
<span class="pre">4)</span></code>, you would
get the expected result: <code class="docutils literal"><span
 class="pre">x</span> <span class="pre">==</span> <span class="pre">5</span>
<span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span
 class="pre">==</span> <span class="pre">625</span></code>. However,
now suppose
that <code class="docutils literal"><span class="pre">*=</span></code>,
when used with matrices, instead mutated the left hand
side. There would be two problems:</p>
<ul class="simple">
  <li>For general square matrices, <code class="docutils literal"><span
 class="pre">A</span> <span class="pre">=</span> <span class="pre">A*B</span></code>
cannot be implemented
without temporary storage: <code class="docutils literal"><span
 class="pre">A[1,1]</span></code> gets computed and stored on
the left hand side before you’re done using it on the right hand
side.</li>
  <li>Suppose you were willing to allocate a temporary for the
computation
(which would eliminate most of the point of making <code
 class="docutils literal"><span class="pre">*=</span></code> work
in-place); if you took advantage of the mutability of <code
 class="docutils literal"><span class="pre">x</span></code>, then
this function would behave differently for mutable vs. immutable
inputs. In particular, for immutable <code class="docutils literal"><span
 class="pre">x</span></code>, after the call you’d
have (in general) <code class="docutils literal"><span class="pre">y</span>
    <span class="pre">!=</span> <span class="pre">x</span></code>, but
for mutable <code class="docutils literal"><span class="pre">x</span></code>
you’d have <code class="docutils literal"><span class="pre">y</span> <span
 class="pre">==</span> <span class="pre">x</span></code>.</li>
</ul>
<p>Because supporting generic programming is deemed more important than
potential performance optimizations that can be achieved by other
means (e.g., using explicit loops), operators like <code
 class="docutils literal"><span class="pre">+=</span></code> and <code
 class="docutils literal"><span class="pre">*=</span></code>
work by rebinding new values.</p>
</div>
</div>
<div class="section"
 id="asynchronous-io-and-concurrent-synchronous-writes">
<h2><span id="result_box" class="short_text" lang="ja"><span>非同期</span>入
出力<span>と</span><span>同時</span><span class="">同期書き込み</span></span><a
 class="headerlink"
 href="#asynchronous-io-and-concurrent-synchronous-writes"
 title="Permalink to this headline"></a></h2>
<div class="section"
 id="why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output">
<h3><span id="result_box" class="short_text" lang="ja"><span>なぜ</span><span>イ
ンター</span><span>混合出力</span><span>で</span><span>同じストリーム</span><span>の</span><span>結
果</span><span>への同時</span><span class="">書き込みを</span><span class="">行いますか</span><span
 class="">？</span></span><a class="headerlink"
 href="#why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output"
 title="Permalink to this headline"></a></h3>
<p>While the streaming I/O API is synchronous, the underlying
implementation
is fully asynchronous.</p>
<p>The following:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="p">@</span><span class="n">sync</span> <span class="k">for</span> <span
 class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span
 class="p">:</span><span class="mi">3</span>
    <span class="p">@</span><span
 class="n">async</span> <span class="n">write</span><span class="p">(</span><span
 class="n">STDOUT</span><span class="p">,</span> <span class="n">string</span><span
 class="p">(</span><span class="n">i</span><span class="p">),</span> <span
 class="s">" Foo "</span><span class="p">,</span> <span class="s">" Bar "</span><span
 class="p">)</span>
<span class="k">end</span>
</pre>
</div>
</div>
<p>results in:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="mi">123</span> <span class="n">Foo</span>  <span
 class="n">Foo</span>  <span class="n">Foo</span>  <span class="n">Bar</span>  <span
 class="n">Bar</span>  <span class="n">Bar</span>
</pre>
</div>
</div>
<p>This is happening because, while the <code class="docutils literal"><span
 class="pre">write</span></code> call is synchronous, the writing of
each argument yields to other tasks while waiting for that part of the
I/O to complete.</p>
<p><code class="docutils literal"><span class="pre">print</span></code>
and <code class="docutils literal"><span class="pre">println</span></code>
“lock” the stream during a call. Consequently changing <code
 class="docutils literal"><span class="pre">write</span></code> to
<code class="docutils literal"><span class="pre">println</span></code>
in the above example results in:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="mi">1</span> <span class="n">Foo</span>  <span
 class="n">Bar</span>
<span class="mi">2</span> <span class="n">Foo</span>  <span class="n">Bar</span>
<span class="mi">3</span> <span class="n">Foo</span>  <span class="n">Bar</span>
</pre>
</div>
</div>
<p>You can lock your writes with a <code class="docutils literal"><span
 class="pre">ReentrantLock</span></code> like this:</p>
<div class="highlight-julia">
<div class="highlight">
<pre><span class="n">l</span> <span class="o">=</span> <span class="n">ReentrantLock</span><span
 class="p">()</span>
<span class="p">@</span><span class="n">sync</span> <span class="k">for</span> <span
 class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span
 class="p">:</span><span class="mi">3</span>
    <span class="p">@</span><span
 class="n">async</span> <span class="k">begin</span>
        <span
 class="n">lock</span><span class="p">(</span><span class="n">l</span><span
 class="p">)</span>
        <span class="k">try</span>
            <span
 class="n">write</span><span class="p">(</span><span class="n">STDOUT</span><span
 class="p">,</span> <span class="n">string</span><span class="p">(</span><span
 class="n">i</span><span class="p">),</span> <span class="s">" Foo "</span><span
 class="p">,</span> <span class="s">" Bar "</span><span class="p">)</span>
        <span
 class="n">finally</span>
            <span class="n">unlock</span><span
 class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span
 class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
</div>
</div>
</div>
<div class="section" id="julia-releases">
<h2>Juliaリリース<a class="headerlink" href="#julia-releases"
 title="Permalink to this headline"></a></h2>
<div class="section"
 id="do-i-want-to-use-a-release-beta-or-nightly-version-of-julia">
<h3><span id="result_box" class="short_text" lang="ja"><span>私は</span>Julia<span>の</span><span>リ
リース</span><span>、</span><span>ベータ</span><span>、</span><span>または</span><span
 class="">古い</span><span class="">バージョンを使用</span><span>しますか</span><span
 class="">？</span></span><a class="headerlink"
 href="#do-i-want-to-use-a-release-beta-or-nightly-version-of-julia"
 title="Permalink to this headline"></a></h3>
<p>You may prefer the release version of Julia if you are looking for a
stable code base. Releases generally occur every 6 months, giving you a
stable platform for writing code.</p>
<p>You may prefer the beta version of Julia if you don’t mind being
slightly behind the latest bugfixes and changes, but find the slightly
faster rate of changes more appealing. Additionally, these binaries are
tested before they are published to ensure they are fully functional.</p>
<p>You may prefer the nightly version of Julia if you want to take
advantage of the latest updates to the language, and don’t mind if the
version available today occasionally doesn’t actually work.</p>
<p>Finally, you may also consider building Julia from source for
yourself. This option is mainly for those individuals who are
comfortable at the command line, or interested in learning. If this
describes you, you may also be interested in reading our <a
 class="reference external"
 href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">guidelines
for contributing</a>.</p>
<p>Links to each of these download types can be found on the download
page at <a class="reference external"
 href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>.
Note that not all versions of Julia are available for all platforms.</p>
</div>
<div class="section" id="when-are-deprecated-functions-removed">
<h3><span id="result_box" class="short_text" lang="ja"><span>ときに</span><span
 class="">廃止予定</span><span class="">の機能が</span><span>削除</span><span
 class="">されますか？</span></span></h3>
<p>Deprecated functions are removed after the subsequent release. For
example, functions marked as deprecated in the 0.1 release will not be
available starting with the 0.2 release.</p>
</div>
</div>
</div>
</div>
<footer> </footer><a href="https://readthedocs.org"></a> </div>
</div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
<script type="text/javascript" src="../_static/jquery.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript"
 src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../_static/js/theme.js"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
</body>
</html>
