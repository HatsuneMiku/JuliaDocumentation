<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]--><!--[if gt IE 8]><!--><!--<![endif]-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Noteworthy Differences from other Languages — Julia Language
0.4.3 documentation</title>
  <link
 href="https://fonts.googleapis.com/css?family=Lato:400,700%7CRoboto+Slab:400,700%7CInconsolata:400,700"
 rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="stylesheet" href="../_static/julia.css" type="text/css">
  <link rel="top" title="Julia Language 0.4.3 documentation"
 href="../index.html">
  <link rel="next" title="Unicode Input" href="unicode-input.html">
  <link rel="prev" title="Frequently Asked Questions" href="faq.html">
  <script
 src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<div class="wy-nav-content">
<div class="rst-content">
<div role="main" class="document">
<div class="section" id="noteworthy-differences-from-other-languages"><span
 id="man-noteworthy-differences"></span>
<h1><span id="result_box" class="short_text" lang="ja"><span>他の</span><span>言
語</span><span class="">からの</span><span class="">注目すべき</span><span
 class="">違い</span></span><a class="headerlink"
 href="#noteworthy-differences-from-other-languages"
 title="Permalink to this headline"></a></h1>
<div class="section" id="noteworthy-differences-from-matlab">
<h2><span id="result_box" class="short_text" lang="ja"><span>MATLAB</span><span>か
らの</span><span>注目すべき</span><span class="">違い</span></span><a
 class="headerlink" href="#noteworthy-differences-from-matlab"
 title="Permalink to this headline"></a></h2>
<p>Although MATLAB users may find Julia’s syntax familiar, Julia is not
a MATLAB
clone. There are major syntactic and functional differences. The
following are
some noteworthy differences that may trip up Julia users accustomed to
MATLAB:</p>
<ul class="simple">
  <li>Julia arrays are indexed with square brackets, <code
 class="docutils literal"><span class="pre">A[i,j]</span></code>.</li>
  <li>Julia arrays are assigned by reference. After <code
 class="docutils literal"><span class="pre">A=B</span></code>, changing
elements of <code class="docutils literal"><span class="pre">B</span></code>
will modify <code class="docutils literal"><span class="pre">A</span></code>
as well.</li>
  <li>Julia values are passed and assigned by reference. If a function
modifies an
array, the changes will be visible in the caller.</li>
  <li>Julia does not automatically grow arrays in an assignment
statement.
Whereas in MATLAB <code class="docutils literal"><span class="pre">a(4)</span>
    <span class="pre">=</span> <span class="pre">3.2</span></code> can
create the array <code class="docutils literal"><span class="pre">a</span>
    <span class="pre">=</span> <span class="pre">[0</span> <span
 class="pre">0</span> <span class="pre">0</span> <span class="pre">3.2]</span></code>
and <code class="docutils literal"><span class="pre">a(5)</span> <span
 class="pre">=</span> <span class="pre">7</span></code> can grow it
into <code class="docutils literal"><span class="pre">a</span> <span
 class="pre">=</span> <span class="pre">[0</span> <span class="pre">0</span>
    <span class="pre">0</span> <span class="pre">3.2</span> <span
 class="pre">7]</span></code>, the corresponding
Julia statement <code class="docutils literal"><span class="pre">a[5]</span>
    <span class="pre">=</span> <span class="pre">7</span></code>
throws an error if the length of <code class="docutils literal"><span
 class="pre">a</span></code> is less
than 5 or if this statement is the first use of the identifier <code
 class="docutils literal"><span class="pre">a</span></code>.
Julia has <a class="reference internal"
 href="../stdlib/collections.html#Base.push%21" title="Base.push!"><code
 class="xref jl jl-func docutils literal"><span class="pre">push!()</span></code></a>
and <a class="reference internal"
 href="../stdlib/collections.html#Base.append%21" title="Base.append!"><code
 class="xref jl jl-func docutils literal"><span class="pre">append!()</span></code></a>,
which grow <code class="xref jl jl-obj docutils literal"><span
 class="pre">Vector</span></code>s
much more efficiently than MATLAB’s <code class="docutils literal"><span
 class="pre">a(end+1)</span> <span class="pre">=</span> <span
 class="pre">val</span></code>.</li>
  <li>The imaginary unit <code class="docutils literal"><span
 class="pre">sqrt(-1)</span></code> is represented in Julia as <a
 class="reference internal" href="../stdlib/numbers.html#Base.im"
 title="Base.im"><code class="xref jl jl-obj docutils literal"><span
 class="pre">im</span></code></a>, not <code class="docutils literal"><span
 class="pre">i</span></code> or <code class="docutils literal"><span
 class="pre">j</span></code> as
in MATLAB.</li>
  <li>In Julia, literal numbers without a decimal point (such as <code
 class="docutils literal"><span class="pre">42</span></code>) create
integers instead of floating point numbers. Arbitrarily large integer
literals are supported. As a result, some operations such as <code
 class="docutils literal"><span class="pre">2^-1</span></code> will
throw a domain error as the result is not an integer (see <a
 class="reference internal" href="faq.html#man-domain-error"><span>the
FAQ entry on domain errors</span></a> for details).</li>
  <li>In Julia, multiple values are returned and assigned as tuples,
e.g. <code class="docutils literal"><span class="pre">(a,</span> <span
 class="pre">b)</span> <span class="pre">=</span> <span class="pre">(1,</span>
    <span class="pre">2)</span></code> or <code
 class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span>
    <span class="pre">=</span> <span class="pre">1,</span> <span
 class="pre">2</span></code>. MATLAB’s <code class="docutils literal"><span
 class="pre">nargout</span></code>, which is
often used in MATLAB to do optional work based on the number of
returned
values, does not exist in Julia. Instead, users can use optional and
keyword
arguments to achieve similar capabilities.</li>
  <li>Julia has true one-dimensional arrays. Column vectors are of size
    <code class="docutils literal"><span class="pre">N</span></code>,
not <code class="docutils literal"><span class="pre">Nx1</span></code>.
For example, <a class="reference internal"
 href="../stdlib/numbers.html#Base.rand" title="Base.rand"><code
 class="xref jl jl-func docutils literal"><span class="pre">rand(N)</span></code></a>
makes a 1-dimensional array.</li>
  <li>In Julia v0.3, concatenating scalars and arrays with the syntax <code
 class="docutils literal"><span class="pre">[x,y,z]</span></code>
concatenates in the first dimension (“vertically”). For concatenation
in the
second dimension (“horizontally”), use spaces as in <code
 class="docutils literal"><span class="pre">[x</span> <span class="pre">y</span>
    <span class="pre">z]</span></code>. To
construct block matrices (concatenating in the first two dimensions),
the syntax <code class="docutils literal"><span class="pre">[a</span> <span
 class="pre">b;</span> <span class="pre">c</span> <span class="pre">d]</span></code>
is used to avoid confusion. In Julia v0.4, the
concatenation syntax <code class="docutils literal"><span class="pre">[x,</span>
    <span class="pre">[y,</span> <span class="pre">z]]</span></code>
is deprecated in favor of <code class="docutils literal"><span
 class="pre">[x;</span> <span class="pre">[y,</span> <span class="pre">z]]</span></code>.</li>
  <li>In Julia, <code class="docutils literal"><span class="pre">a:b</span></code>
and <code class="docutils literal"><span class="pre">a:b:c</span></code>
construct <code class="xref jl jl-obj docutils literal"><span
 class="pre">Range</span></code> objects. To construct
a full vector like in MATLAB, use <a class="reference internal"
 href="../stdlib/collections.html#Base.collect" title="Base.collect"><code
 class="xref jl jl-func docutils literal"><span class="pre">collect(a:b)</span></code></a>.
Generally,
there is no need to call <code class="docutils literal"><span
 class="pre">collect</span></code> though. <code
 class="docutils literal"><span class="pre">Range</span></code> will
act like a normal
array in most cases but is more efficient because it lazily computes
its
values. This pattern of creating specialized objects instead of full
arrays
is used frequently, and is also seen in functions such as <a
 class="reference internal" href="../stdlib/arrays.html#Base.linspace"
 title="Base.linspace"><code class="xref jl jl-func docutils literal"><span
 class="pre">linspace</span></code></a>, or with iterators such as <a
 class="reference internal"
 href="../stdlib/collections.html#Base.enumerate" title="Base.enumerate"><code
 class="xref jl jl-func docutils literal"><span class="pre">enumerate</span></code></a>,
and <a class="reference internal"
 href="../stdlib/collections.html#Base.zip" title="Base.zip"><code
 class="xref jl jl-func docutils literal"><span class="pre">zip</span></code></a>.
The special objects can mostly be used as if they were
normal arrays.</li>
  <li>Functions in Julia return values from their last expression or
the <code class="docutils literal"><span class="pre">return</span></code>
keyword instead of listing the names of variables to return in the
function
definition (see <a class="reference internal"
 href="functions.html#man-return-keyword"><span>The return Keyword</span></a>
for details).</li>
  <li>A Julia script may contain any number of functions, and all
definitions will
be externally visible when the file is loaded. Function definitions can
be
loaded from files outside the current working directory.</li>
  <li>In Julia, reductions such as <a class="reference internal"
 href="../stdlib/collections.html#Base.sum" title="Base.sum"><code
 class="xref jl jl-func docutils literal"><span class="pre">sum()</span></code></a>,
    <a class="reference internal"
 href="../stdlib/collections.html#Base.prod" title="Base.prod"><code
 class="xref jl jl-func docutils literal"><span class="pre">prod()</span></code></a>,
and <a class="reference internal" href="../stdlib/math.html#Base.max"
 title="Base.max"><code class="xref jl jl-func docutils literal"><span
 class="pre">max()</span></code></a> are
performed over every element of an array when called with a single
argument,
as in <code class="docutils literal"><span class="pre">sum(A)</span></code>,
even if <code class="docutils literal"><span class="pre">A</span></code>
has more than one dimension.</li>
  <li>In Julia, functions such as <a class="reference internal"
 href="../stdlib/sort.html#Base.sort" title="Base.sort"><code
 class="xref jl jl-func docutils literal"><span class="pre">sort()</span></code></a>
that operate column-wise by default
(<code class="docutils literal"><span class="pre">sort(A)</span></code>
is equivalent to <code class="docutils literal"><span class="pre">sort(A,1)</span></code>)
do not have special behavior for <code class="docutils literal"><span
 class="pre">1xN</span></code>
arrays; the argument is returned unmodified since it still performs <code
 class="docutils literal"><span class="pre">sort(A,1)</span></code>.
To sort a <code class="docutils literal"><span class="pre">1xN</span></code>
matrix like a vector, use <code class="docutils literal"><span
 class="pre">sort(A,2)</span></code>.</li>
  <li>In Julia, if <code class="docutils literal"><span class="pre">A</span></code>
is a 2-dimensional array, <code class="docutils literal"><span
 class="pre">fft(A)</span></code> computes a 2D FFT. In
particular, it is not equivalent to <code class="docutils literal"><span
 class="pre">fft(A,1)</span></code>, which computes a 1D FFT
acting column-wise.</li>
  <li>In Julia, parentheses must be used to call a function with zero
arguments,
like in <a class="reference internal"
 href="../stdlib/base.html#Base.tic" title="Base.tic"><code
 class="xref jl jl-func docutils literal"><span class="pre">tic()</span></code></a>
and <a class="reference internal" href="../stdlib/base.html#Base.toc"
 title="Base.toc"><code class="xref jl jl-func docutils literal"><span
 class="pre">toc()</span></code></a>.</li>
  <li>Julia discourages the used of semicolons to end statements. The
results of
statements are not automatically printed (except at the interactive
prompt),
and lines of code do not need to end with semicolons. <a
 class="reference internal"
 href="../stdlib/io-network.html#Base.println" title="Base.println"><code
 class="xref jl jl-func docutils literal"><span class="pre">println()</span></code></a>
or <a class="reference internal"
 href="../stdlib/io-network.html#Base.@printf" title="Base.@printf"><code
 class="xref jl jl-func docutils literal"><span class="pre">@printf()</span></code></a>
can be used to print specific output.</li>
  <li>In Julia, if <code class="docutils literal"><span class="pre">A</span></code>
and <code class="docutils literal"><span class="pre">B</span></code>
are arrays, logical comparison operations like <code
 class="docutils literal"><span class="pre">A</span> <span class="pre">==</span>
    <span class="pre">B</span></code> do not return
an array of booleans. Instead, use <code class="docutils literal"><span
 class="pre">A</span> <span class="pre">.==</span> <span class="pre">B</span></code>,
and
similarly for the other boolean operators like <a
 class="reference internal" href="../stdlib/math.html#Base.%3C"
 title="Base.&lt;"><code class="xref jl jl-obj docutils literal"><span
 class="pre">&lt;</span></code></a>, <a class="reference internal"
 href="../stdlib/math.html#Base.%3E" title="Base.&gt;"><code
 class="xref jl jl-obj docutils literal"><span class="pre">&gt;</span></code></a>
and <code class="xref jl jl-obj docutils literal"><span class="pre">=</span></code>.</li>
  <li>In Julia, the operators <a class="reference internal"
 href="../stdlib/math.html#Base.&amp;" title="Base.&amp;"><code
 class="xref jl jl-obj docutils literal"><span class="pre">&amp;</span></code></a>,
    <a class="reference internal" href="../stdlib/math.html#Base.%7C"
 title="Base.|"><code class="xref jl jl-obj docutils literal"><span
 class="pre">|</span></code></a>, and <a class="reference internal"
 href="../stdlib/math.html#Base.$" title="Base.$"><code
 class="xref jl jl-obj docutils literal"><span class="pre">$</span></code></a>
perform the bitwise
operations equivalent to <code class="docutils literal"><span
 class="pre">and</span></code>, <code class="docutils literal"><span
 class="pre">or</span></code>, and <code class="docutils literal"><span
 class="pre">xor</span></code> respectively in MATLAB,
and have precedence similar to Python’s bitwise operators (unlike C).
They
can operate on scalars or element-wise across arrays and can be used to
combine logical arrays, but note the difference in order of operations:
parentheses may be required (e.g., to select elements of <code
 class="docutils literal"><span class="pre">A</span></code> equal to 1
or
2 use <code class="docutils literal"><span class="pre">(A</span> <span
 class="pre">.==</span> <span class="pre">1)</span> <span class="pre">|</span>
    <span class="pre">(A</span> <span class="pre">.==</span> <span
 class="pre">2)</span></code>).</li>
  <li>In Julia, the elements of a collection can be passed as arguments
to a
function using the splat operator <code class="docutils literal"><span
 class="pre">...</span></code>, as in <code class="docutils literal"><span
 class="pre">xs=[1,2];</span> <span class="pre">f(xs...)</span></code>.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/linalg.html#Base.svd" title="Base.svd"><code
 class="xref jl jl-func docutils literal"><span class="pre">svd()</span></code></a>
returns singular values as a vector instead of as a dense
diagonal matrix.</li>
  <li>In Julia, <code class="docutils literal"><span class="pre">...</span></code>
is not used to continue lines of code. Instead, incomplete
expressions automatically continue onto the next line.</li>
  <li>In both Julia and MATLAB, the variable <code
 class="docutils literal"><span class="pre">ans</span></code> is set to
the value of the
last expression issued in an interactive session. In Julia, unlike
MATLAB, <code class="docutils literal"><span class="pre">ans</span></code>
is not set when Julia code is run in non-interactive mode.</li>
  <li>Julia’s <code class="docutils literal"><span class="pre">type</span></code>s
do not support dynamically adding fields at runtime,
unlike MATLAB’s <code class="docutils literal"><span class="pre">class</span></code>es.
Instead, use a <a class="reference internal"
 href="../stdlib/collections.html#Base.Dict" title="Base.Dict"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Dict</span></code></a>.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-r">
<h2><span id="result_box" class="short_text" lang="ja"><span>R</span><span>か
らの</span><span>注目すべき</span><span class="">違い</span></span><a
 class="headerlink" href="#noteworthy-differences-from-r"
 title="Permalink to this headline"></a></h2>
<p>One of Julia’s goals is to provide an effective language for data
analysis
and statistical programming. For users coming to Julia from R, these
are some
noteworthy differences:</p>
<ul class="simple">
  <li>Julia’s single quotes enclose characters, not strings.</li>
  <li>Julia can create substrings by indexing into strings. In R,
strings
must be converted into character vectors before creating substrings.</li>
  <li>In Julia, like Python but unlike R, strings can be created with
triple quotes <code class="docutils literal"><span class="pre">"""</span>
    <span class="pre">...</span> <span class="pre">"""</span></code>.
This
syntax is convenient for constructing strings that
contain line breaks.</li>
  <li>In Julia, varargs are specified using the splat operator <code
 class="docutils literal"><span class="pre">...</span></code>, which
always follows the name of a specific variable, unlike R, for which <code
 class="docutils literal"><span class="pre">...</span></code>
can occur in isolation.</li>
  <li>In Julia, modulus, is <a class="reference internal"
 href="../stdlib/math.html#Base.%" title="Base.%"><code
 class="xref jl jl-obj docutils literal"><span class="pre">%</span></code></a>,
not <code class="docutils literal"><span class="pre">%%</span></code>.</li>
  <li>In Julia, not all data structures support logical indexing.
Furthermore,
logical indexing in Julia is supported only with vectors of length
equal to
the object being indexed. For example:
- In R, <code class="docutils literal"><span class="pre">c(1,</span> <span
 class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4)[c(TRUE,</span>
    <span class="pre">FALSE)]</span></code> is equivalent to <code
 class="docutils literal"><span class="pre">c(1,3)</span></code>.
- In R, <code class="docutils literal"><span class="pre">c(1,</span> <span
 class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4)[c(TRUE,</span>
    <span class="pre">FALSE,</span> <span class="pre">TRUE,</span> <span
 class="pre">FALSE)]</span></code> is equivalent to <code
 class="docutils literal"><span class="pre">c(1,3)</span></code>.
- In Julia, <code class="docutils literal"><span class="pre">[1,</span>
    <span class="pre">2,</span> <span class="pre">3,</span> <span
 class="pre">4][[true,</span> <span class="pre">false]]</span></code>
throws a <a class="reference internal"
 href="../stdlib/base.html#Base.BoundsError" title="Base.BoundsError"><code
 class="xref jl jl-exc docutils literal"><span class="pre">BoundsError</span></code></a>.
- In Julia, <code class="docutils literal"><span class="pre">[1,</span>
    <span class="pre">2,</span> <span class="pre">3,</span> <span
 class="pre">4][[true,</span> <span class="pre">false,</span> <span
 class="pre">true,</span> <span class="pre">false]]</span></code>
produces <code class="docutils literal"><span class="pre">[1,</span> <span
 class="pre">3]</span></code>.</li>
  <li>Like many languages, Julia does not always allow operations on
vectors of
different lengths, unlike R where the vectors only need to share a
common
index range. For example, <code class="docutils literal"><span
 class="pre">c(1,2,3,4)</span> <span class="pre">+</span> <span
 class="pre">c(1,2)</span></code> is valid R but the
equivalent <code class="docutils literal"><span class="pre">[1:4]</span>
    <span class="pre">+</span> <span class="pre">[1:2]</span></code>
will throw an error in Julia.</li>
  <li>Julia’s <code class="xref jl jl-func docutils literal"><span
 class="pre">apply()</span></code> takes the function first, then its
arguments, unlike <code class="docutils literal"><span class="pre">lapply(&lt;structure&gt;,</span>
    <span class="pre">function,</span> <span class="pre">arg2,</span> <span
 class="pre">...)</span></code> in R.</li>
  <li>Julia uses <code class="docutils literal"><span class="pre">end</span></code>
to denote the end of conditional blocks, like <code
 class="docutils literal"><span class="pre">if</span></code>,
loop blocks, like <code class="docutils literal"><span class="pre">while</span></code>/<code
 class="docutils literal"><span class="pre">for</span></code>, and
functions. In lieu of the one-line <code class="docutils literal"><span
 class="pre">if</span> <span class="pre">(</span> <span class="pre">cond</span>
    <span class="pre">)</span> <span class="pre">statement</span></code>,
Julia allows statements
of the form <code class="docutils literal"><span class="pre">if</span>
    <span class="pre">cond;</span> <span class="pre">statement;</span>
    <span class="pre">end</span></code>, <code class="docutils literal"><span
 class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span
 class="pre">statement</span></code> and <code class="docutils literal"><span
 class="pre">!cond</span> <span class="pre">||</span> <span
 class="pre">statement</span></code>.
Assignment statements in the latter two syntaxes must
be explicitly wrapped in parentheses, e.g. <code
 class="docutils literal"><span class="pre">cond</span> <span
 class="pre">&amp;&amp;</span> <span class="pre">(x</span> <span
 class="pre">=</span> <span class="pre">value)</span></code>.</li>
  <li>In Julia, <code class="docutils literal"><span class="pre">&lt;-</span></code>,
    <code class="docutils literal"><span class="pre">&lt;&lt;-</span></code>
and <code class="docutils literal"><span class="pre">-&gt;</span></code>
are not assignment operators.</li>
  <li>Julia’s <code class="docutils literal"><span class="pre">-&gt;</span></code>
creates an anonymous function, like Python.</li>
  <li>Julia constructs vectors using brackets. Julia’s <code
 class="docutils literal"><span class="pre">[1,</span> <span
 class="pre">2,</span> <span class="pre">3]</span></code> is the
equivalent of R’s <code class="docutils literal"><span class="pre">c(1,</span>
    <span class="pre">2,</span> <span class="pre">3)</span></code>.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/strings.html#Base.*" title="Base.*"><code
 class="xref jl jl-obj docutils literal"><span class="pre">*</span></code></a>
operator can perform matrix multiplication, unlike in R.
If <code class="docutils literal"><span class="pre">A</span></code>
and <code class="docutils literal"><span class="pre">B</span></code>
are matrices, then <code class="docutils literal"><span class="pre">A</span>
    <span class="pre">*</span> <span class="pre">B</span></code>
denotes a matrix
multiplication in Julia, equivalent to R’s <code
 class="docutils literal"><span class="pre">A</span> <span class="pre">%*%</span>
    <span class="pre">B</span></code>. In R, this same
notation would perform an element-wise (Hadamard) product. To get the
element-wise multiplication operation, you need to write <code
 class="docutils literal"><span class="pre">A</span> <span class="pre">.*</span>
    <span class="pre">B</span></code> in Julia.</li>
  <li>Julia performs matrix transposition using the <code
 class="xref jl jl-obj docutils literal"><span class="pre">'</span></code>
operator and conjugated
transposition using the <code class="xref jl jl-obj docutils literal"><span
 class="pre">'</span></code> operator. Julia’s <code
 class="docutils literal"><span class="pre">A.'</span></code> is
therefore
equivalent to R’s <code class="docutils literal"><span class="pre">t(A)</span></code>.</li>
  <li>Julia does not require parentheses when writing <code
 class="docutils literal"><span class="pre">if</span></code> statements
or <code class="docutils literal"><span class="pre">for</span></code>/<code
 class="docutils literal"><span class="pre">while</span></code> loops:
use <code class="docutils literal"><span class="pre">for</span> <span
 class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,</span>
    <span class="pre">2,</span> <span class="pre">3]</span></code>
instead of <code class="docutils literal"><span class="pre">for</span>
    <span class="pre">(i</span> <span class="pre">in</span> <span
 class="pre">c(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code>
and <code class="docutils literal"><span class="pre">if</span> <span
 class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code>
instead of <code class="docutils literal"><span class="pre">if</span> <span
 class="pre">(i</span> <span class="pre">==</span> <span class="pre">1)</span></code>.</li>
  <li>Julia does not treat the numbers <code class="docutils literal"><span
 class="pre">0</span></code> and <code class="docutils literal"><span
 class="pre">1</span></code> as Booleans.
You cannot write <code class="docutils literal"><span class="pre">if</span>
    <span class="pre">(1)</span></code> in Julia, because <code
 class="docutils literal"><span class="pre">if</span></code> statements
accept only
booleans. Instead, you can write <code class="docutils literal"><span
 class="pre">if</span> <span class="pre">true</span></code>, <code
 class="docutils literal"><span class="pre">if</span> <span class="pre">Bool(1)</span></code>,
or <code class="docutils literal"><span class="pre">if</span> <span
 class="pre">1==1</span></code>.</li>
  <li>Julia does not provide <code class="docutils literal"><span
 class="pre">nrow</span></code> and <code class="docutils literal"><span
 class="pre">ncol</span></code>. Instead, use <code
 class="docutils literal"><span class="pre">size(M,</span> <span
 class="pre">1)</span></code>
for <code class="docutils literal"><span class="pre">nrow(M)</span></code>
and <code class="docutils literal"><span class="pre">size(M,</span> <span
 class="pre">2)</span></code> for <code class="docutils literal"><span
 class="pre">ncol(M)</span></code>.</li>
  <li>Julia is careful to distinguish scalars, vectors and matrices. In
R, <code class="docutils literal"><span class="pre">1</span></code>
and <code class="docutils literal"><span class="pre">c(1)</span></code>
are the same. In Julia, they can not be used
interchangeably. One potentially confusing result of this is that <code
 class="docutils literal"><span class="pre">x'</span> <span class="pre">*</span>
    <span class="pre">y</span></code> for vectors <code
 class="docutils literal"><span class="pre">x</span></code> and <code
 class="docutils literal"><span class="pre">y</span></code> is a
1-element vector, not a scalar.
To get a scalar, use <a class="reference internal"
 href="../stdlib/linalg.html#Base.dot" title="Base.dot"><code
 class="xref jl jl-func docutils literal"><span class="pre">dot(x,</span>
    <span class="pre">y)</span></code></a>.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/linalg.html#Base.diag" title="Base.diag"><code
 class="xref jl jl-func docutils literal"><span class="pre">diag()</span></code></a>
and <a class="reference internal"
 href="../stdlib/linalg.html#Base.diagm" title="Base.diagm"><code
 class="xref jl jl-func docutils literal"><span class="pre">diagm()</span></code></a>
are not like R’s.</li>
  <li>Julia cannot assign to the results of function calls on the left
hand side of
an assignment operation: you cannot write <code
 class="docutils literal"><span class="pre">diag(M)</span> <span
 class="pre">=</span> <span class="pre">ones(n)</span></code>.</li>
  <li>Julia discourages populating the main namespace with functions.
Most
statistical functionality for Julia is found in <a
 class="reference external" href="http://pkg.julialang.org/">packages</a>
under the <a class="reference external"
 href="https://github.com/JuliaStats">JuliaStats organization</a>. For
example:
    <ul>
      <li>Functions pertaining to probability distributions are
provided by the <a class="reference external"
 href="https://github.com/JuliaStats/Distributions.jl">Distributions
package</a>.</li>
      <li>The <a class="reference external"
 href="https://github.com/JuliaStats/DataFrames.jl">DataFrames package</a>
provides data frames.</li>
      <li>Generalized linear models are provided by the <a
 class="reference external" href="https://github.com/JuliaStats/GLM.jl">GLM
package</a>.</li>
    </ul>
  </li>
  <li>Julia provides tuples and real hash tables, but not R-style
lists. When
returning multiple items, you should typically use a tuple: instead of <code
 class="docutils literal"><span class="pre">list(a</span> <span
 class="pre">=</span> <span class="pre">1,</span> <span class="pre">b</span>
    <span class="pre">=</span> <span class="pre">2)</span></code>, use
    <code class="docutils literal"><span class="pre">(1,</span> <span
 class="pre">2)</span></code>.</li>
  <li>Julia encourages users to write their own types, which are easier
to use than
S3 or S4 objects in R. Julia’s multiple dispatch system means that <code
 class="docutils literal"><span class="pre">table(x::TypeA)</span></code>
and <code class="docutils literal"><span class="pre">table(x::TypeB)</span></code>
act like R’s <code class="docutils literal"><span class="pre">table.TypeA(x)</span></code>
and <code class="docutils literal"><span class="pre">table.TypeB(x)</span></code>.</li>
  <li>In Julia, values are passed and assigned by reference. If a
function modifies
an array, the changes will be visible in the caller. This is very
different
from R and allows new functions to operate on large data structures
much more
efficiently.</li>
  <li>In Julia, vectors and matrices are concatenated using <a
 class="reference internal" href="../stdlib/arrays.html#Base.hcat"
 title="Base.hcat"><code class="xref jl jl-func docutils literal"><span
 class="pre">hcat()</span></code></a>, <a class="reference internal"
 href="../stdlib/arrays.html#Base.vcat" title="Base.vcat"><code
 class="xref jl jl-func docutils literal"><span class="pre">vcat()</span></code></a>
and <a class="reference internal"
 href="../stdlib/arrays.html#Base.hvcat" title="Base.hvcat"><code
 class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></code></a>,
not <code class="docutils literal"><span class="pre">c</span></code>, <code
 class="docutils literal"><span class="pre">rbind</span></code> and <code
 class="docutils literal"><span class="pre">cbind</span></code> like in
R.</li>
  <li>In Julia, a range like <code class="docutils literal"><span
 class="pre">a:b</span></code> is not shorthand for a vector like in R,
but is a specialized <code class="xref jl jl-obj docutils literal"><span
 class="pre">Range</span></code> that is used for iteration without
high
memory overhead. To convert a range into a vector, use <a
 class="reference internal"
 href="../stdlib/collections.html#Base.collect" title="Base.collect"><code
 class="xref jl jl-func docutils literal"><span class="pre">collect(a:b)</span></code></a>.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/math.html#Base.max" title="Base.max"><code
 class="xref jl jl-func docutils literal"><span class="pre">max()</span></code></a>
and <a class="reference internal" href="../stdlib/math.html#Base.min"
 title="Base.min"><code class="xref jl jl-func docutils literal"><span
 class="pre">min()</span></code></a> are the equivalent of <code
 class="docutils literal"><span class="pre">pmax</span></code> and <code
 class="docutils literal"><span class="pre">pmin</span></code>
respectively in R, but both arguments need to have the same
dimensions. While <a class="reference internal"
 href="../stdlib/collections.html#Base.maximum" title="Base.maximum"><code
 class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></code></a>
and <a class="reference internal"
 href="../stdlib/collections.html#Base.minimum" title="Base.minimum"><code
 class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></code></a>
replace <code class="docutils literal"><span class="pre">max</span></code>
and <code class="docutils literal"><span class="pre">min</span></code>
in R, there are important differences.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/collections.html#Base.sum" title="Base.sum"><code
 class="xref jl jl-func docutils literal"><span class="pre">sum()</span></code></a>,
    <a class="reference internal"
 href="../stdlib/collections.html#Base.prod" title="Base.prod"><code
 class="xref jl jl-func docutils literal"><span class="pre">prod()</span></code></a>,
    <a class="reference internal"
 href="../stdlib/collections.html#Base.maximum" title="Base.maximum"><code
 class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></code></a>,
and <a class="reference internal"
 href="../stdlib/collections.html#Base.minimum" title="Base.minimum"><code
 class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></code></a>
are
different from their counterparts in R. They all accept one or two
arguments.
The first argument is an iterable collection such as an array. If there
is a
second argument, then this argument indicates the dimensions, over
which the
operation is carried out. For instance, let <code
 class="docutils literal"><span class="pre">A=[[1</span> <span
 class="pre">2],[3</span> <span class="pre">4]]</span></code> in Julia
and <code class="docutils literal"><span class="pre">B=rbind(c(1,2),c(3,4))</span></code>
be the same matrix in R. Then <code class="docutils literal"><span
 class="pre">sum(A)</span></code> gives
the same result as <code class="docutils literal"><span class="pre">sum(B)</span></code>,
but <code class="docutils literal"><span class="pre">sum(A,</span> <span
 class="pre">1)</span></code> is a row vector containing
the sum over each column and <code class="docutils literal"><span
 class="pre">sum(A,</span> <span class="pre">2)</span></code> is a
column vector containing the
sum over each row. This contrasts to the behavior of R, where <code
 class="docutils literal"><span class="pre">sum(B,1)=11</span></code>
and <code class="docutils literal"><span class="pre">sum(B,2)=12</span></code>.
If the second argument is a vector,
then it specifies all the dimensions over which the sum is performed,
e.g., <code class="docutils literal"><span class="pre">sum(A,[1,2])=10</span></code>.
It should be noted that there is no error checking
regarding the second argument.</li>
  <li>Julia has several functions that can mutate their arguments. For
example,
it has both <a class="reference internal"
 href="../stdlib/sort.html#Base.sort" title="Base.sort"><code
 class="xref jl jl-func docutils literal"><span class="pre">sort()</span></code></a>
and <a class="reference internal"
 href="../stdlib/sort.html#Base.sort%21" title="Base.sort!"><code
 class="xref jl jl-func docutils literal"><span class="pre">sort!()</span></code></a>.</li>
  <li>In R, performance requires vectorization. In Julia, almost the
opposite is
true: the best performing code is often achieved by using devectorized
loops.</li>
  <li>Julia is eagerly evaluated and does not support R-style lazy
evaluation. For
most users, this means that there are very few unquoted expressions or
column
names.</li>
  <li>Julia does not support the <code class="docutils literal"><span
 class="pre">NULL</span></code> type.</li>
  <li>Julia lacks the equivalent of R’s <code class="docutils literal"><span
 class="pre">assign</span></code> or <code class="docutils literal"><span
 class="pre">get</span></code>.</li>
  <li>In Julia, <code class="docutils literal"><span class="pre">return</span></code>
does not require parentheses.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-python">
<h2><span id="result_box" class="short_text" lang="ja"><span>Python</span><span>か
らの</span><span class="">注目すべき</span><span class="">違い</span></span><a
 class="headerlink" href="#noteworthy-differences-from-python"
 title="Permalink to this headline"></a></h2>
<ul class="simple">
  <li>In Julia, a vector of vectors can automatically concatenate into
a
one-dimensional vector <em>if</em> no explicit element type is
specified. For example:
    <ul>
      <li>In Julia, <code class="docutils literal"><span class="pre">[1,</span>
        <span class="pre">[2,</span> <span class="pre">3]]</span></code>
concatenates into <code class="docutils literal"><span class="pre">[1,</span>
        <span class="pre">2,</span> <span class="pre">3]</span></code>,
like in R.</li>
      <li>In Julia, <code class="docutils literal"><span class="pre">Int[1,</span>
        <span class="pre">Int[2,</span> <span class="pre">3]]</span></code>
will <em>not</em> concatenate, but instead throw an error.</li>
      <li>In Julia, <code class="docutils literal"><span class="pre">Any[1,</span>
        <span class="pre">[2,3]]</span></code> will <em>not</em>
concatenate.</li>
      <li>In Julia, <code class="docutils literal"><span class="pre">Vector{Int}[[1,</span>
        <span class="pre">2],</span> <span class="pre">[3,</span> <span
 class="pre">4]]</span></code> will <em>not</em> concatenate, but
produces an object similar to Python’s list of lists. This object is <em>different</em>
from a two-dimensional <a class="reference internal"
 href="../stdlib/arrays.html#Base.Array" title="Base.Array"><code
 class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>
of <code class="xref jl jl-obj docutils literal"><span class="pre">Int</span></code>s.</li>
    </ul>
  </li>
  <li>Julia requires <code class="docutils literal"><span class="pre">end</span></code>
to end a block. Unlike Python, Julia has no <code
 class="docutils literal"><span class="pre">pass</span></code>
keyword.</li>
  <li>In Julia, indexing of arrays, strings, etc. is 1-based not
0-based.</li>
  <li>Julia’s slice indexing includes the last element, unlike in
Python. <code class="docutils literal"><span class="pre">a[2:3]</span></code>
in Julia is <code class="docutils literal"><span class="pre">a[1:3]</span></code>
in Python.</li>
  <li>Julia does not support negative indexes. In particular, the last
element of a
list or array is indexed with <code
 class="xref jl jl-obj docutils literal"><span class="pre">end</span></code>
in Julia, not <code class="docutils literal"><span class="pre">-1</span></code>
as in Python.</li>
  <li>Julia’s list comprehensions do not support the optional <code
 class="docutils literal"><span class="pre">if</span></code> clause
that
Python has.</li>
  <li>Julia’s <code class="docutils literal"><span class="pre">for</span></code>,
    <code class="docutils literal"><span class="pre">if</span></code>, <code
 class="docutils literal"><span class="pre">while</span></code>, etc.
blocks are terminated by the <code class="docutils literal"><span
 class="pre">end</span></code>
keyword. Indentation level is not significant as it is in Python.</li>
  <li>Julia has no line continuation syntax: if, at the end of a line,
the input so
far is a complete expression, it is considered done; otherwise the
input
continues. One way to force an expression to continue is to wrap it in
parentheses.</li>
  <li>Julia arrays are column major (Fortran ordered) whereas NumPy
arrays are row
major (C-ordered) by default. To get optimal performance when looping
over
arrays, the order of the loops should be reversed in Julia relative to
NumPy
(see relevant section of <a class="reference internal"
 href="performance-tips.html#man-performance-tips"><span>Performance
Tips</span></a>).</li>
  <li>Julia’s updating operators (e.g. <code class="docutils literal"><span
 class="pre">+=</span></code>, <code class="docutils literal"><span
 class="pre">-=</span></code>, ...) are <em>not in-place</em>
whereas NumPy’s are. This means <code class="docutils literal"><span
 class="pre">A</span> <span class="pre">=</span> <span class="pre">ones(4);</span>
    <span class="pre">B</span> <span class="pre">=</span> <span
 class="pre">A;</span> <span class="pre">B</span> <span class="pre">+=</span>
    <span class="pre">3</span></code> doesn’t change
values in <code class="docutils literal"><span class="pre">A</span></code>,
it rather rebinds the name <code class="docutils literal"><span
 class="pre">B</span></code> to the result of the right-
hand side <code class="docutils literal"><span class="pre">B</span> <span
 class="pre">=</span> <span class="pre">B</span> <span class="pre">+</span>
    <span class="pre">3</span></code>, which is a new array. Use <code
 class="docutils literal"><span class="pre">B[:]</span> <span
 class="pre">+=</span> <span class="pre">3</span></code>, explicit
loops,
or <code class="docutils literal"><span class="pre">InplaceOps.jl</span></code>.</li>
  <li>Julia evaluates default values of function arguments every time
the method is
invoked, unlike in Python where the default values are evaluated only
once
when the function is defined. For example, the function <code
 class="docutils literal"><span class="pre">f(x=rand())</span> <span
 class="pre">=</span> <span class="pre">x</span></code>
returns a new random number every time it is invoked without argument.
On the
other hand, the function <code class="docutils literal"><span
 class="pre">g(x=[1,2])</span> <span class="pre">=</span> <span
 class="pre">push!(x,3)</span></code> returns <code
 class="docutils literal"><span class="pre">[1,2,3]</span></code> every
time it is called as <code class="docutils literal"><span class="pre">g()</span></code>.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-c-c">
<h2><span id="result_box" class="short_text" lang="ja"><span>C</span><span>/</span><span
 class="hps">C</span><span>++ からの</span><span>注目すべき</span><span class="">違
い</span></span><a class="headerlink"
 href="#noteworthy-differences-from-c-c"
 title="Permalink to this headline"></a></h2>
<ul class="simple">
  <li>Julia arrays are indexed with square brackets, and can have more
than one
dimension <code class="docutils literal"><span class="pre">A[i,j]</span></code>.
This syntax is not just syntactic sugar for a reference to a pointer or
address as in C/C++.
See the Julia documentation for the syntax for array construction (it
has changed between versions).</li>
  <li>In Julia, indexing of arrays, strings, etc. is 1-based not
0-based.</li>
  <li>Julia arrays are assigned by reference. After <code
 class="docutils literal"><span class="pre">A=B</span></code>, changing
elements of <code class="docutils literal"><span class="pre">B</span></code>
will modify <code class="docutils literal"><span class="pre">A</span></code>
as well. Updating operators like <code class="docutils literal"><span
 class="pre">+=</span></code> do not operate
in-place, they are equivalent to <code class="docutils literal"><span
 class="pre">A</span> <span class="pre">=</span> <span class="pre">A</span>
    <span class="pre">+</span> <span class="pre">B</span></code> which
rebinds the left-hand
side to the result of the right-hand side expression.</li>
  <li>Julia arrays are column major (Fortran ordered) whereas C/C++
arrays are row
major ordered by default. To get optimal performance when looping over
arrays, the order of the loops should be reversed in Julia relative to
C/C++
(see relevant section of <a class="reference internal"
 href="performance-tips.html#man-performance-tips"><span>Performance
Tips</span></a>).</li>
  <li>Julia values are passed and assigned by reference. If a function
modifies an
array, the changes will be visible in the caller.</li>
  <li>In Julia, whitespace is significant, unlike C/C++, so care must
be taken when adding/removing
whitespace from a Julia program.</li>
  <li>In Julia, literal numbers without a decimal point (such as <code
 class="docutils literal"><span class="pre">42</span></code>) create
signed
integers, of type <code class="docutils literal"><span class="pre">Int</span></code>,
but literals too large to fit in the machine word size
will automatically be promoted to a larger size type, such as <code
 class="docutils literal"><span class="pre">Int64</span></code> (if <code
 class="docutils literal"><span class="pre">Int</span></code> is <code
 class="docutils literal"><span class="pre">Int32</span></code>), <code
 class="docutils literal"><span class="pre">Int128</span></code>,
or the arbitrarily large <code class="docutils literal"><span
 class="pre">BigInt</span></code> type.
There are no numeric literal suffixes, such as <code
 class="docutils literal"><span class="pre">L</span></code>, <code
 class="docutils literal"><span class="pre">LL</span></code>, <code
 class="docutils literal"><span class="pre">U</span></code>, <code
 class="docutils literal"><span class="pre">UL</span></code>, <code
 class="docutils literal"><span class="pre">ULL</span></code> to
indicate unsigned
and/or signed vs. unsigned.
Decimal literals are always signed, and hexadecimal literals (which
start with <code class="docutils literal"><span class="pre">0x</span></code>
like C/C++),
are unsigned.
Hexadecimal literals also, unlike C/C++/Java and unlike decimal
literals in Julia,
have a type based on the <em>length</em> of the literal, including
leading 0s. For example, <code class="docutils literal"><span
 class="pre">0x0</span></code>
and <code class="docutils literal"><span class="pre">0x00</span></code>
have type UInt8, <code class="docutils literal"><span class="pre">0x000</span></code>
and <code class="docutils literal"><span class="pre">0x0000</span></code>
have type <code class="docutils literal"><span class="pre">UInt16</span></code>,
then
literals with 5 to 8 hex digits have type <code
 class="docutils literal"><span class="pre">UInt32</span></code>, 9 to
16 hex digits type <code class="docutils literal"><span class="pre">UInt64</span></code>
and 17 to 32 hex digits type <code class="docutils literal"><span
 class="pre">UInt128</span></code>.
This needs to be taken into account when defining
hexadecimal masks, for example <code class="docutils literal"><span
 class="pre">~0xf</span> <span class="pre">==</span> <span class="pre">0xf0</span></code>
is very different from <code class="docutils literal"><span class="pre">~0x000f</span>
    <span class="pre">==</span> <span class="pre">0xfff0</span></code>.
64 bit <code class="docutils literal"><span class="pre">Float64</span></code>
and 32 bit <code class="docutils literal"><span class="pre">Float32</span></code>
bit literals are expressed as <code class="docutils literal"><span
 class="pre">1.0</span></code> and <code class="docutils literal"><span
 class="pre">1.0f0</span></code> respectively.
Floating point literals are rounded (and not promoted to the <code
 class="docutils literal"><span class="pre">BigFloat</span></code>
type) if they can not be exactly
represented. Floating point literals are closer in behavior to C/C++.
Octal (prefixed with <code class="docutils literal"><span class="pre">0o</span></code>)
and binary (prefixed with <code class="docutils literal"><span
 class="pre">0b</span></code>) literals are also treated as unsigned.</li>
  <li>String literals can be delimited with either <code
 class="docutils literal"><span class="pre">"</span></code> or <code
 class="docutils literal"><span class="pre">"""</span></code>, <code
 class="docutils literal"><span class="pre">"""</span></code> delimited
literals can contain <code class="docutils literal"><span class="pre">"</span></code>
characters without quoting it like <code class="docutils literal"><span
 class="pre">"\""</span></code>
String literals can have values of other variables or expressions
interpolated into them,
indicated by <code class="docutils literal"><span class="pre">$variablename</span></code>
or <code class="docutils literal"><span class="pre">$(expression)</span></code>,
which evaluates the variable name or the expression in the context of
the function.</li>
  <li><code class="docutils literal"><span class="pre">//</span></code>
indicates a <code class="docutils literal"><span class="pre">Rational</span></code>
number, and not a single-line comment (which is <code
 class="docutils literal"><span class="pre">#</span></code> in Julia)</li>
  <li><code class="docutils literal"><span class="pre">#=</span></code>
indicates the start of a multiline comment, and <code
 class="docutils literal"><span class="pre">=#</span></code> ends it.</li>
  <li>Functions in Julia return values from their last expression(s) or
the <code class="docutils literal"><span class="pre">return</span></code>
keyword. Multiple values can be returned from functions and assigned as
tuples, e.g. <code class="docutils literal"><span class="pre">(a,</span>
    <span class="pre">b)</span> <span class="pre">=</span> <span
 class="pre">myfunction()</span></code>
or <code class="docutils literal"><span class="pre">a,</span> <span
 class="pre">b</span> <span class="pre">=</span> <span class="pre">myfunction()</span></code>,
instead of having to pass pointers
to values as one would have to do in C/C++ (i.e. <code
 class="docutils literal"><span class="pre">a</span> <span class="pre">=</span>
    <span class="pre">myfunction(&amp;b)</span></code>.</li>
  <li>Julia does not require the use of semicolons to end statements.
The results of
expressions are not automatically printed (except at the interactive
prompt, i.e. the REPL),
and lines of code do not need to end with semicolons. <a
 class="reference internal"
 href="../stdlib/io-network.html#Base.println" title="Base.println"><code
 class="xref jl jl-func docutils literal"><span class="pre">println()</span></code></a>
or <a class="reference internal"
 href="../stdlib/io-network.html#Base.@printf" title="Base.@printf"><code
 class="xref jl jl-func docutils literal"><span class="pre">@printf()</span></code></a>
can be used to print specific output.
In the REPL, <code class="docutils literal"><span class="pre">;</span></code>
can be used to suppress output. <code class="docutils literal"><span
 class="pre">;</span></code>
also has a different meaning within <code class="docutils literal"><span
 class="pre">[</span> <span class="pre">]</span></code>, something to
watch out for. <code class="docutils literal"><span class="pre">;</span></code>
can be used to separate expressions on a single line, but are not
strictly necessary in many cases,
and are more an aid to readability.</li>
  <li>In Julia, the operator <a class="reference internal"
 href="../stdlib/math.html#Base.$" title="Base.$"><code
 class="xref jl jl-obj docutils literal"><span class="pre">$</span></code></a>
performs the bitwise XOR operation, i.e. <a class="reference internal"
 href="../stdlib/strings.html#Base.%5E" title="Base.^"><code
 class="xref jl jl-obj docutils literal"><span class="pre">^</span></code></a>
in C/C++. Also, the bitwise operators do not have the same precedence
as C/++,
so parenthesis may be required.</li>
  <li>Julia’s <a class="reference internal"
 href="../stdlib/strings.html#Base.%5E" title="Base.^"><code
 class="xref jl jl-obj docutils literal"><span class="pre">^</span></code></a>
is exponentiation (pow), not bitwise XOR as in C/C++ (use <a
 class="reference internal" href="../stdlib/math.html#Base.$"
 title="Base.$"><code class="xref jl jl-obj docutils literal"><span
 class="pre">$</span></code></a> in Julia)</li>
  <li>Julia has two right-shift operators, <code
 class="docutils literal"><span class="pre">&gt;&gt;</span></code> and <code
 class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>.
    <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>
performs an arithmetic shift, <code class="docutils literal"><span
 class="pre">&gt;&gt;</span></code>
always performs a logical shift, unlike C/C++,
where the meaning of <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>
depends on the type of the value being shifted.</li>
  <li>Julia’s <code class="docutils literal"><span class="pre">-&gt;</span></code>
creates an anonymous function, it does not access a member via a
pointer.</li>
  <li>Julia does not require parentheses when writing <code
 class="docutils literal"><span class="pre">if</span></code> statements
or <code class="docutils literal"><span class="pre">for</span></code>/<code
 class="docutils literal"><span class="pre">while</span></code> loops:
use <code class="docutils literal"><span class="pre">for</span> <span
 class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,</span>
    <span class="pre">2,</span> <span class="pre">3]</span></code>
instead of <code class="docutils literal"><span class="pre">for</span>
    <span class="pre">(int</span> <span class="pre">i=1;</span> <span
 class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">3;</span>
    <span class="pre">i++)</span></code> and <code
 class="docutils literal"><span class="pre">if</span> <span class="pre">i</span>
    <span class="pre">==</span> <span class="pre">1</span></code>
instead of <code class="docutils literal"><span class="pre">if</span> <span
 class="pre">(i</span> <span class="pre">==</span> <span class="pre">1)</span></code>.</li>
  <li>Julia does not treat the numbers <code class="docutils literal"><span
 class="pre">0</span></code> and <code class="docutils literal"><span
 class="pre">1</span></code> as Booleans.
You cannot write <code class="docutils literal"><span class="pre">if</span>
    <span class="pre">(1)</span></code> in Julia, because <code
 class="docutils literal"><span class="pre">if</span></code> statements
accept only
booleans. Instead, you can write <code class="docutils literal"><span
 class="pre">if</span> <span class="pre">true</span></code>, <code
 class="docutils literal"><span class="pre">if</span> <span class="pre">Bool(1)</span></code>,
or <code class="docutils literal"><span class="pre">if</span> <span
 class="pre">1==1</span></code>.</li>
  <li>Julia uses <code class="docutils literal"><span class="pre">end</span></code>
to denote the end of conditional blocks, like <code
 class="docutils literal"><span class="pre">if</span></code>,
loop blocks, like <code class="docutils literal"><span class="pre">while</span></code>/<code
 class="docutils literal"><span class="pre">for</span></code>, and
functions. In lieu of the one-line <code class="docutils literal"><span
 class="pre">if</span> <span class="pre">(</span> <span class="pre">cond</span>
    <span class="pre">)</span> <span class="pre">statement</span></code>,
Julia allows statements
of the form <code class="docutils literal"><span class="pre">if</span>
    <span class="pre">cond;</span> <span class="pre">statement;</span>
    <span class="pre">end</span></code>, <code class="docutils literal"><span
 class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span
 class="pre">statement</span></code> and <code class="docutils literal"><span
 class="pre">!cond</span> <span class="pre">||</span> <span
 class="pre">statement</span></code>.
Assignment statements in the latter two syntaxes must
be explicitly wrapped in parentheses, e.g. <code
 class="docutils literal"><span class="pre">cond</span> <span
 class="pre">&amp;&amp;</span> <span class="pre">(x</span> <span
 class="pre">=</span> <span class="pre">value)</span></code>, because
of the operator precedence.</li>
  <li>Julia has no line continuation syntax: if, at the end of a line,
the input so
far is a complete expression, it is considered done; otherwise the
input
continues. One way to force an expression to continue is to wrap it in
parentheses.</li>
  <li>Julia macros operate on parsed expressions, rather than the text
of the program,
which allows them to perform sophisticated transformations of Julia
code. Macro
names start with the <code class="docutils literal"><span class="pre">@</span></code>
character, and have both a function-like syntax, <code
 class="docutils literal"><span class="pre">@mymacro(arg1,</span> <span
 class="pre">arg2,</span> <span class="pre">arg3)</span></code>,
and a statement-like syntax, <code class="docutils literal"><span
 class="pre">@mymacro</span> <span class="pre">arg1</span> <span
 class="pre">arg2</span> <span class="pre">arg3</span></code>. The
forms are interchangable; the
function-like form
is particularly useful if the macro appears within another expression,
and is often clearest.
The statement-like form is often used to annotate blocks, as in the
parallel <code class="docutils literal"><span class="pre">for</span></code>
construct: <code class="docutils literal"><span class="pre">@parallel</span>
    <span class="pre">for</span> <span class="pre">i</span> <span
 class="pre">in</span> <span class="pre">1:n;</span> <span class="pre">#=</span>
    <span class="pre">body</span> <span class="pre">=#;</span> <span
 class="pre">end</span></code>. Where the end of the macro
construct may be unclear, use the function-like form.</li>
  <li>Julia now has an enumeration type, expressed using the macro <code
 class="docutils literal"><span class="pre">@enum(name,</span> <span
 class="pre">value1,</span> <span class="pre">value2,</span> <span
 class="pre">...)</span></code>
For example: <code class="docutils literal"><span class="pre">@enum(Fruit,</span>
    <span class="pre">Banana=1,</span> <span class="pre">Apple,</span>
    <span class="pre">Pear)</span></code></li>
  <li>By convention, functions that modify their arguments have a <code
 class="docutils literal"><span class="pre">!</span></code> at the end
of the name,
for example <code class="docutils literal"><span class="pre">push!</span></code>.</li>
  <li>In C++, by default, you have static dispatch, i.e. you need to
annotate a function as virtual,
in order to have dynamic dispatch.
On the other hand, in Julia every method is “virtual” (although it’s
more general than that
since methods are dispatched on every argument type, not only <code
 class="docutils literal"><span class="pre">this</span></code>, using
the most-specific-declaration rule).</li>
</ul>
</div>
</div>
</div>
<footer> </footer><a href="https://readthedocs.org"></a> </div>
</div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
<script type="text/javascript" src="../_static/jquery.js"></script>
<script type="text/javascript" src="../_static/underscore.js"></script>
<script type="text/javascript" src="../_static/doctools.js"></script>
<script type="text/javascript"
 src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../_static/js/theme.js"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
</body>
</html>
